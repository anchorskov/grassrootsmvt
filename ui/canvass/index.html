<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Canvass</title>
<script src="/config/environments.js"></script>
<script src="/src/apiClient.v2.js?v=2025-10-30a"></script>
<script src="/shared/authGlobal.js"></script>
<script src="../shared/streetAutocompleteOptimized.js"></script>
<script src="../shared/houseAutocomplete.js"></script>
<style>
  :root { --gap: 10px; }
  body { font-family: system-ui, sans-serif; margin: 12px; position: relative; }
  .auth-inline {
    margin: 4px 0 12px;
    padding: 6px 12px;
    border-radius: 8px;
    background: #e0f2fe;
    color: #0f172a;
    font-size: 0.9rem;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px; margin:12px 0; box-shadow:0 1px 2px rgba(0,0,0,.04); }
  h1 { font-size: 1.4rem; margin: 4px 0 12px; }
  .row { display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center; }
  .row > * { flex:1 1 140px; }
  label { font-size:.9rem; color:#334155; }
  input[type=number], input[type=text], select, button {
    width:100%; font-size:1rem; padding:.7rem .75rem; border:1px solid #cbd5e1; border-radius:10px;
  }
  input:disabled {
    background-color: #f8fafc;
    color: #64748b;
    cursor: not-allowed;
    border-color: #e2e8f0;
  }
  button.primary { background:#2563eb; color:white; border:0; font-weight:600; }
  .muted { color:#64748b }
  .autocomplete-container { position: relative; }
  .autocomplete-suggestions { 
    position: absolute; 
    top: 100%; 
    left: 0; 
    right: 0; 
    background: white; 
    border: 2px solid #2563eb; 
    border-top: none; 
    border-radius: 0 0 10px 10px; 
    max-height: 200px; 
    overflow-y: auto; 
    z-index: 9999; 
    display: none; 
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  .autocomplete-suggestion { 
    padding: 12px 16px; 
    cursor: pointer; 
    border-bottom: 1px solid #f1f5f9; 
    font-weight: 500;
    background: white;
  }
  .autocomplete-suggestion:hover { background: #f8fafc; border-color: #e2e8f0; }
  .autocomplete-suggestion:last-child { border-bottom: none; }
  .person-name { font-weight:700; font-size:1.1rem; color:#1e293b; margin-bottom:4px; }
  .addr { font-weight:500; color:#475569; font-size:.95rem; }
  .location-details { font-size:.85rem; color:#64748b; margin-top:2px; }
  .chip { display:inline-block; border:1px solid #cbd5e1; border-radius:999px; padding:.15rem .5rem; font-size:.8rem; margin-left:6px; }
  button[disabled] { opacity:.45; cursor:not-allowed; }
  .muted-chip { border:1px solid #e5e7eb; color:#64748b; }
  .list > div { padding:10px 0; border-bottom:1px solid #f1f5f9; }
  .list > div:last-child { border-bottom:0; }
  .toolbar { display:flex; gap:8px; }
</style>
</head>

<body>
<h1>Canvass</h1>
<div class="auth-inline" id="authInline">Checking sign-inâ€¦</div>

<div class="card">
  <div class="muted" id="filtersBadge">Loading filtersâ€¦</div>
</div>

<div class="card">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
    <h3 style="margin: 0; color: #1e293b;">Address Lookup</h3>
    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9rem; color: #475569;">
      <input type="checkbox" id="instructionsToggle" style="margin: 0;" checked>
      Show step-by-step instructions
    </label>
  </div>
  
  <div id="instructionsPanel" style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
    <div id="instructionText" style="font-weight: 500; color: #0369a1;">
      ğŸ‘‹ Click the Street field and start typing at least two letters
    </div>
  </div>
  <div id="districtStreetsStatus" class="muted" style="display:none; margin-bottom: 8px;"></div>

  <div class="card">
    <div class="row">
      <div class="autocomplete-container">
        <label for="house">House #</label>
        <input id="house" type="text" placeholder="Select street first" inputmode="numeric" autocomplete="off" disabled />
        <div id="houseSuggestions" class="autocomplete-suggestions"></div>
      </div>
      <div class="autocomplete-container">
        <label for="street">Street</label>
        <input id="street" type="text" placeholder="Start typing street name" autocomplete="off" />
        <div id="streetSuggestions" class="autocomplete-suggestions"></div>
      </div>
    </div>
  <div class="row" style="margin-top:8px;">
    <div>
      <label for="range">Number range (Â±)</label>
      <select id="range">
        <option>10</option><option selected>20</option><option>30</option><option>50</option>
      </select>
    </div>
    <div>
      <label for="limit">Max addresses</label>
      <select id="limit">
        <option>10</option><option selected>20</option><option>30</option><option>50</option>
      </select>
    </div>
  </div>
  <div class="row" style="margin-top:10px;">
    <button class="primary" id="btnFind">Find nearby</button>
  </div>
  <div id="msg" class="muted" style="margin-top:8px;"></div>
</div>

<div class="card">
  <div class="list" id="results"></div>
</div>

<div id="toast" style="position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#111827;color:white;padding:8px 12px;border-radius:8px;display:none;box-shadow:0 4px 12px rgba(0,0,0,.2);">Opening call...</div>

<script>
  console.clear();

  // Debug snippet: Cloudflare Access now manages authentication. Manual token storage removed.
const API = (p = '', params = {}) =>
  window.environmentConfig.getApiUrl(String(p).replace(/^\/+/, ''), params);

const RETURN_PATH_KEY = 'contactUpdateReturnTo';
const CANVASS_STATE_KEY = 'canvassPageState';
const CANVASS_STATE_KEEP_FLAG = 'canvassStateKeep';
let latestRows = [];
const WY_META_PATHS = ['/admin/wy.json', '/ui/admin/wy.json'];
let wyMetaCache = null;
const DISTRICT_STREET_LIMIT = 400;
const DISTRICT_CITY_SCAN_LIMIT = 12;
let districtStreetSeedPromise = null;
let streetAutocomplete;
const districtStreetsStatusEl = document.getElementById('districtStreetsStatus');

function fromQS() {
  const u = new URL(location.href);
  const parties = u.searchParams.getAll('parties');
    const f = {
      county: (u.searchParams.get('county')||'').toUpperCase() || null,
      city:   (u.searchParams.get('city')||'').toUpperCase() || null,
      district_type: u.searchParams.get('district_type') || null,
      district: u.searchParams.get('district') || null,
      parties: parties.length ? parties : [],
    };
    return f;
  }

  function showFiltersBadge(f) {
    const badge = document.getElementById('filtersBadge');
    badge.textContent = 'Filters: ' + JSON.stringify(f);
  }

  async function jsonFetch(url, init = {}) {
    if (typeof window.apiFetch !== 'function') {
      throw new Error('API client not ready');
    }
    const path = String(url).replace(/^\/?api\/?/, '');
    const response = await window.apiFetch(path, init);
    const text = await response.text().catch(() => '');
    if (!response.ok) {
      const error = new Error(`HTTP ${response.status}`);
      error.status = response.status;
      error.body = text;
      throw error;
    }
    if (!text) return null;
    try {
      return JSON.parse(text);
    } catch {
      return text;
    }
  }

function setMsg(t) { document.getElementById('msg').textContent = t || ''; }

function setDistrictStreetsStatus(text, tone = 'muted') {
  if (!districtStreetsStatusEl) return;
  if (!text) {
    districtStreetsStatusEl.style.display = 'none';
    districtStreetsStatusEl.style.color = '';
    districtStreetsStatusEl.textContent = '';
    return;
  }
  districtStreetsStatusEl.style.display = '';
  const palette = {
    muted: '#475569',
    success: '#166534',
    warning: '#92400e',
    error: '#b91c1c',
  };
  districtStreetsStatusEl.style.color = palette[tone] || palette.muted;
  districtStreetsStatusEl.textContent = text;
}

async function waitForApiClientMethods() {
  const started = Date.now();
  while (typeof window.apiPost !== 'function') {
    await new Promise(resolve => setTimeout(resolve, 25));
    if (Date.now() - started > 5000) {
      throw new Error('API client not ready');
    }
  }
}

async function loadWyMeta() {
  if (wyMetaCache) return wyMetaCache;
  let lastErr = null;
  for (const path of WY_META_PATHS) {
    try {
      const res = await fetch(path, { cache: 'no-store' });
      if (!res.ok) {
        lastErr = new Error(`${path} -> HTTP ${res.status}`);
        continue;
      }
      const data = await res.json();
      const normalized = {};
      Object.entries(data.citiesByCounty || {}).forEach(([county, list]) => {
        normalized[county.toUpperCase()] = (list || []).map(city => city.toUpperCase());
      });
      wyMetaCache = { citiesByCounty: normalized };
      return wyMetaCache;
    } catch (err) {
      lastErr = err;
    }
  }
  throw lastErr || new Error('Unable to load metadata');
}

function normalizeCountyName(value) {
  return (value || '').toString().trim().toUpperCase();
}

async function preloadDistrictStreets(filters) {
  if (!filters?.district_type || !filters?.district) return;
  if (districtStreetSeedPromise) return districtStreetSeedPromise;
  districtStreetSeedPromise = (async () => {
    try {
      await waitForApiClientMethods();
      setDistrictStreetsStatus(`Loading streets for District ${filters.district}â€¦`);
      const payload = {
        filters: {
          county: filters.county || null,
          city: filters.city || null,
          district_type: filters.district_type,
          district: filters.district,
          parties: filters.parties || [],
        },
        limit: DISTRICT_STREET_LIMIT,
      };
      const response = await window.apiFetch('canvass/nearby', {
        method: 'POST',
        body: JSON.stringify(payload),
      });
      const text = await response.text();
      const data = text ? JSON.parse(text) : { rows: [] };
      const rows = Array.isArray(data.rows) ? data.rows : [];
      const streets = new Set();
      rows.forEach(row => {
        const addr = row.address || '';
        const street = addr.replace(/^\d+\s+/, '').trim().toUpperCase();
        if (street) streets.add(street);
      });
      const list = Array.from(streets).sort();
      if (streetAutocomplete) {
        streetAutocomplete.setSeededStreets(list);
      }
      if (list.length) {
        setDistrictStreetsStatus(`Loaded ${list.length} streets found in District ${filters.district}.`, 'success');
      } else {
        setDistrictStreetsStatus('No streets found for this district yet. Try typing to search manually.', 'warning');
      }
    } catch (err) {
      console.error('Unable to preload district streets', err);
      setDistrictStreetsStatus('Unable to preload streets for this district.', 'error');
    } finally {
      districtStreetSeedPromise = null;
    }
  })();
  return districtStreetSeedPromise;
}

function getCanvassFormValues() {
  return {
    house: document.getElementById('house').value || '',
    street: document.getElementById('street').value || '',
    range: document.getElementById('range').value || '',
    limit: document.getElementById('limit').value || ''
  };
}

function setCanvassStateKeepFlag(enabled) {
  if (enabled) {
    sessionStorage.setItem(CANVASS_STATE_KEEP_FLAG, '1');
  } else {
    sessionStorage.removeItem(CANVASS_STATE_KEEP_FLAG);
  }
}

function shouldRestoreCanvassState() {
  const keep = sessionStorage.getItem(CANVASS_STATE_KEEP_FLAG) === '1';
  if (!keep) {
    sessionStorage.removeItem(CANVASS_STATE_KEY);
    return false;
  }
  sessionStorage.removeItem(CANVASS_STATE_KEEP_FLAG);
  return true;
}

function persistCanvassState(rows = latestRows, { protect = false } = {}) {
  try {
    const state = {
      ...getCanvassFormValues(),
      rows: Array.isArray(rows) ? rows : [],
      msg: document.getElementById('msg')?.textContent || '',
      url: window.location.pathname + window.location.search,
      ts: Date.now()
    };
    sessionStorage.setItem(CANVASS_STATE_KEY, JSON.stringify(state));
    if (protect) {
      setCanvassStateKeepFlag(true);
    }
  } catch (e) {
    console.warn('âš ï¸ Unable to save canvass state:', e);
  }
}

function restoreCanvassState() {
  if (!shouldRestoreCanvassState()) return;
  const raw = sessionStorage.getItem(CANVASS_STATE_KEY);
  if (!raw) return;
  try {
    const state = JSON.parse(raw);
    const currentUrl = window.location.pathname + window.location.search;
    if (state.url && state.url !== currentUrl) return;
    
    const streetInput = document.getElementById('street');
    const houseInput = document.getElementById('house');
    const rangeSelect = document.getElementById('range');
    const limitSelect = document.getElementById('limit');
    
    if (state.street) {
      streetInput.value = state.street;
      enableHouseField();
    }
    if (state.house) {
      houseInput.value = state.house;
    }
    if (state.range && Array.from(rangeSelect.options).some(opt => opt.value === String(state.range))) {
      rangeSelect.value = state.range;
    }
    if (state.limit && Array.from(limitSelect.options).some(opt => opt.value === String(state.limit))) {
      limitSelect.value = state.limit;
    }
    
    if (Array.isArray(state.rows) && state.rows.length) {
      latestRows = state.rows;
      renderList(state.rows).catch(err => console.warn('âš ï¸ Failed to restore canvass list:', err));
    }
    if (state.msg) {
      setMsg(state.msg);
    }
  } catch (e) {
    console.warn('âš ï¸ Unable to restore canvass state:', e);
  }
}

  async function renderList(rows) {
    console.log('ğŸ¨ renderList called with:', rows);
    const el = document.getElementById('results');
    console.log('ğŸ¨ Results element:', el);
    latestRows = Array.isArray(rows) ? rows : [];
    
    el.innerHTML = '';
    if (!rows || !rows.length) { 
      console.log('ğŸ¨ No rows to display');
      el.innerHTML = '<div class="muted">No nearby addresses.</div>'; 
      return; 
    }
    
    console.log('ğŸ¨ Rendering', rows.length, 'rows');
    
    const voterLookup = new Map(rows.map(r => [String(r.voter_id), r]));
    
    // Fetch contact status for all voters
    let contactStatus = {};
    try {
      const voter_ids = rows.map(r => r.voter_id).join(',');
      console.log('ğŸ“ Fetching contact status for voter IDs:', voter_ids);
      
      const response = await jsonFetch(`/api/contact/status?voter_ids=${voter_ids}`);
      if (response.ok) {
        contactStatus = response.contacts || {};
        console.log('ğŸ“ Contact status loaded:', contactStatus);
      }
    } catch (error) {
      console.warn('âš ï¸ Failed to load contact status:', error);
    }
    
    for (const r of rows) {
      const div = document.createElement('div');
      div.className = 'voter-card'; // Add a class to identify voter cards
      
      // Get contact info for this voter
      const contact = contactStatus[r.voter_id];
      let contactInfo = '';
      
      if (contact) {
        const contactDate = new Date(contact.created_at).toLocaleDateString();
        const volunteer = contact.volunteer_email || 'Unknown';
        const shortVolunteer = volunteer.split('@')[0]; // Show just the username part
        
        // Style based on contact outcome
        let statusColor = '#6b7280'; // gray
        let statusIcon = 'ğŸ“‹';
        
        switch (contact.outcome?.toLowerCase()) {
          case 'connected':
          case 'contacted':
          case 'brief':
            statusColor = '#059669'; // green
            statusIcon = 'âœ…';
            break;
          case 'no_answer':
          case 'not home':
            statusColor = '#d97706'; // orange
            statusIcon = 'ğŸšª';
            break;
          case 'refused':
          case 'dnc':
          case 'do not contact':
            statusColor = '#dc2626'; // red
            statusIcon = 'ğŸš«';
            break;
          case 'moved':
          case 'wrong_address':
            statusColor = '#7c3aed'; // purple
            statusIcon = 'ğŸ“¦';
            break;
        }
        
        contactInfo = `
          <div class="contact-status" style="margin-top:4px; padding:4px 8px; background:#f8fafc; border-left:3px solid ${statusColor}; font-size:0.85rem;">
            ${statusIcon} <strong>${contact.outcome}</strong> by ${shortVolunteer} on ${contactDate}
            ${contact.method ? ` (${contact.method})` : ''}
          </div>
        `;
      }
      
      const districtChips = [
        r.house_district ? `<span class="chip muted-chip">HD ${r.house_district}</span>` : '',
        r.senate_district ? `<span class="chip muted-chip">SD ${r.senate_district}</span>` : ''
      ].filter(Boolean).join(' ');

      div.innerHTML = `
        <div class="person-name">${r.name || 'Name Unknown'} <span style="font-size:0.8rem;font-weight:400;color:#64748b;">(ID: ${r.voter_id})</span></div>
        <div class="addr">${r.address}</div>
        <div class="location-details">${r.city} ${r.zip}
          <span class="chip">${r.party||'Unknown Party'}</span>
          ${r.phone_e164
            ? `<span class="chip">${r.phone_e164}${r.phone_confidence ? ' ('+r.phone_confidence+')' : ''}</span>`
            : `<span class="chip muted-chip">no phone</span>`}
          ${districtChips}
        </div>
        ${contactInfo}
        <div class="toolbar" style="margin-top:8px;">
          <button data-id="${r.voter_id}" data-a="contacted" style="background: #059669; color: white; font-weight: 500;">ğŸ“‹ Contact</button>
          <button data-id="${r.voter_id}" data-a="no_answer">ğŸšª Not Home</button>
          <button data-id="${r.voter_id}" data-a="note">ğŸ“ Note</button>
    <button data-id="${r.voter_id}" data-a="call"
      class="primary"
      ${r.phone_e164 ? '' : 'disabled title="No phone on file" aria-disabled="true"'}
    >Call</button>
        </div>
      `;
      el.appendChild(div);
    }
    el.querySelectorAll('button[data-a]').forEach(btn => {
      btn.addEventListener('click', async () => {
        const voter_id = btn.getAttribute('data-id');
        let outcome = btn.getAttribute('data-a');
        let comments = null;
        
        if (outcome === 'call') {
          // Prefill call UI and show toast then navigate there
          try {
            const pre = { voter_id, prefill: true };
            sessionStorage.setItem('vol.call_prefill', JSON.stringify(pre));
            persistCanvassState(undefined, { protect: true });
            const toast = document.getElementById('toast');
            toast.style.display = 'block';
            setTimeout(() => { toast.style.display = 'none'; location.href = '/call.html?voter_id=' + encodeURIComponent(voter_id); }, 700);
          } catch (e) {
            alert('Unable to open call UI: ' + e.message);
          }
          return;
        }
        
        if (outcome === 'contacted') {
          // Navigate to dedicated contact page with voter data
          let voterCard = btn.closest('.voter-card'); // Use the specific class
          console.log('ğŸ” Debug: voterCard found:', !!voterCard);
          console.log('ğŸ” Debug: button element:', btn);
          console.log('ğŸ” Debug: button parent:', btn.parentElement);
          
          if (!voterCard) {
            console.error('ğŸš¨ Contact button error: Voter card not found');
            console.log('ğŸ” Debug: Trying alternative selector...');
            
            // Fallback: try to find the voter card by traversing up
            let testCard = btn.parentElement;
            while (testCard && !testCard.querySelector('.person-name')) {
              testCard = testCard.parentElement;
              if (testCard === document.body) break; // Safety check
            }
            
            if (testCard && testCard.querySelector('.person-name')) {
              console.log('ğŸ” Debug: Found voter card via fallback method');
              voterCard = testCard; // Assign to the voterCard variable
            } else {
              alert('Error: Could not find voter card. Please try again.');
              return;
            }
          }
          
          const voterNameElement = voterCard.querySelector('.person-name');
          const voterAddressElement = voterCard.querySelector('.addr');
          const locationDetailsElement = voterCard.querySelector('.location-details');
          
          console.log('ğŸ” Debug elements found:', {
            voterName: !!voterNameElement,
            voterAddress: !!voterAddressElement, 
            locationDetails: !!locationDetailsElement
          });
          
          if (!voterNameElement || !voterAddressElement || !locationDetailsElement) {
            console.error('ğŸš¨ Contact button error: Required voter elements not found');
            console.log('ğŸ” Debug HTML structure:', voterCard?.innerHTML || 'voterCard is null');
            alert('Error: Could not find voter information. Please try again.');
            return;
          }
          
          const voterName = voterNameElement.textContent.split(' (ID:')[0];
          const voterAddress = voterAddressElement.textContent;
          const locationDetails = locationDetailsElement.textContent;
          
          // Parse city, zip, and party from location details
          const parts = locationDetails.split('â€¢').map(p => p.trim());
          const cityZip = parts[0] || '';
          const [city, zip] = cityZip.split(' ').filter(p => p);
          const party = parts.find(p => !p.includes('phone') && !cityZip.includes(p)) || '';
          const phone = parts.find(p => p.includes('+1') || p.includes('phone')) || '';
          
          const contactUrl = `/contact?${new URLSearchParams({
            voter_id: voter_id,
            name: voterName,
            address: voterAddress,
            city: city || '',
            zip: zip || '',
            party: party.replace(/[^\w\s]/g, '').trim(),
            phone: phone.replace('no phone', '')
          }).toString()}`;
          
          persistCanvassState(undefined, { protect: true });
          window.location.href = contactUrl;
          return;
        }
        
        if (outcome === 'note') {
          const voterRow = voterLookup.get(String(voter_id));
          if (!voterRow) {
            alert('Unable to load voter details for this note. Please refresh and try again.');
            return;
          }
          
          const returnPath = (window.location.pathname + window.location.search) || '/canvass/index.html';
          persistCanvassState(undefined, { protect: true });
          try {
            sessionStorage.setItem('voterUpdateData', JSON.stringify(voterRow));
            sessionStorage.setItem(RETURN_PATH_KEY, returnPath);
          } catch (e) {
            console.warn('âš ï¸ Unable to cache voter data locally:', e);
          }
          
          const params = new URLSearchParams({
            voter_id,
            data: JSON.stringify(voterRow),
            return_to: returnPath
          });
          
          window.location.href = `/contact-form/update.html?${params.toString()}`;
          return;
        }
        
        // Handle simple outcomes (no_answer, etc.)
        try {
          await jsonFetch(API('/complete'), { method:'POST', body: JSON.stringify({ voter_id, outcome, comments }) });
          btn.closest('div').querySelectorAll('button').forEach(b => b.disabled = true);
        } catch (e) {
          alert('Save failed: '+e.message);
        }
      });
    });
  }

  async function findNearby() {
    const house = Number(document.getElementById('house').value || 0);
    const street = (document.getElementById('street').value || '').trim().toUpperCase();
    const range  = Number(document.getElementById('range').value);
    const limit  = Number(document.getElementById('limit').value);
    
    console.log('ğŸ” findNearby called with:', { house, street, range, limit });
    
    if (!house || !street) {
      setMsg('Enter a house number and street.'); return;
    }
    setMsg('Searchingâ€¦');
    const filters = fromQS();
    
    console.log('ğŸ” Making API call with filters:', filters);
    console.log('ğŸ” API URL will be:', API('/canvass/nearby'));
    
  try {
    const requestBody = { filters, house, street, range, limit };
    console.log('ğŸ” Request body:', requestBody);
    
    const j = await jsonFetch(API('/canvass/nearby'), {
        method: 'POST',
        body: JSON.stringify(requestBody)
      });
    
    console.log('ğŸ” API response:', j);
    console.log('ğŸ” Response rows:', j.rows);
    
    await renderList(j.rows || []);
    setMsg(`Found ${j.rows?.length||0} nearby addresses.`);
    persistCanvassState(j.rows || []);
  } catch (e) {
    console.error('ğŸ” Error in findNearby:', e);
    setMsg('Error: '+e.message);
  }
}

  // Street autocomplete functionality
  let streetCache = null;
  async function loadStreetNames() {
    if (streetCache) return streetCache;
    try {
      // Get a sample of addresses to build street list
      const filters = fromQS();
      console.log('ğŸ” Loading streets with filters:', filters);
      console.log('ğŸŒ Current URL:', location.href);
      
      const response = await jsonFetch(API('/canvass/nearby'), {
        method: 'POST', 
        body: JSON.stringify({ filters, limit: 500 })
      });
      
      console.log('ğŸ“¡ API Response:', response);
      
      const streets = [...new Set((response.rows || []).map(r => {
        // Extract street name from full address (remove house number)
        return r.address.replace(/^\d+\s+/, '').toUpperCase();
      }))].sort();
      streetCache = streets;
      console.log(`âœ… Loaded ${streets.length} street names for autocomplete:`, streets);
      return streets;
    } catch (e) {
      console.error('âŒ Failed to load street names:', e);
      return [];
    }
  }

  // Enable house number field
  function enableHouseField() {
    const houseInput = document.getElementById('house');
    houseInput.disabled = false;
    houseInput.placeholder = "e.g. 5201";
    houseInput.style.backgroundColor = "";
    houseInput.style.cursor = "";
  }

  // Disable house number field  
  function disableHouseField() {
    const houseInput = document.getElementById('house');
    const houseSuggestions = document.getElementById('houseSuggestions');
    
    houseInput.disabled = true;
    houseInput.value = "";
    houseInput.placeholder = "Select street first";
    houseSuggestions.style.display = 'none';
  }

  // House numbers now handled by HouseAutocomplete component

document.getElementById('btnFind').addEventListener('click', findNearby);
window.addEventListener('pagehide', () => persistCanvassState());
  
  // QoL: Enter on street field triggers search
  const streetEl = document.getElementById('street');
  document.getElementById('street').addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); findNearby(); }
  });
  // Auto-uppercase input to reduce mismatches
  streetEl.addEventListener('input', () => {
    const pos = streetEl.selectionStart;
    streetEl.value = (streetEl.value || '').toUpperCase();
    streetEl.selectionStart = streetEl.selectionEnd = pos;
  });
  
  restoreCanvassState();

  // Initialize reusable house autocomplete component
  const houseAutocomplete = new HouseAutocomplete({
    houseInputId: 'house',
    suggestionsId: 'houseSuggestions',
    getCounty: () => fromQS().county,
    getCity: () => fromQS().city,
    getStreet: () => document.getElementById('street').value,
    onHouseSelected: (houseNumber, houseData) => {
      console.log('ğŸ  House selected:', houseNumber);
      updateInstruction('houseSelected');
    }
  });
  
  // Initialize reusable street autocomplete component
  streetAutocomplete = new StreetAutocompleteOptimized({
    streetInputId: 'street',
    houseInputId: 'house',
    suggestionsId: 'streetSuggestions',
    getCounty: () => fromQS().county,
    getCity: () => fromQS().city,
    onStreetSelected: async (streetName) => {
      // Enable house number field
      houseAutocomplete.enable();
      
      // Update instructions when street is selected
      updateInstruction('streetSelected');
      
      // Load house numbers for this street
      await houseAutocomplete.loadHouseNumbers(streetName);
    },
    onHouseFieldChange: (enabled) => {
      if (enabled) {
        houseAutocomplete.enable();
      } else {
        houseAutocomplete.disable();
      }
    }
  });
  
  // Instructions system
  const instructionsToggle = document.getElementById('instructionsToggle');
  const instructionsPanel = document.getElementById('instructionsPanel');
  const instructionText = document.getElementById('instructionText');
  
  console.log('ğŸ›ï¸ Instructions elements found:', {
    toggle: !!instructionsToggle,
    panel: !!instructionsPanel, 
    text: !!instructionText
  });
  
  // Instructions state management
  let currentStep = 'street';
  const instructions = {
    street: 'ğŸ‘‹ Click the Street field and start typing at least two letters',
    streetFocused: 'ğŸ“ Keep typing â€” suggestions appear once you enter two or more letters',
    streetSelected: 'ğŸ  Great! Now select a house number from the yellow dropdown above',
    houseSelected: 'ğŸ” Perfect! Click "Find nearby" to search for voters',
    searching: 'â³ Searching for nearby voters...',
    results: 'âœ… Found results! Review the voters below and take action',
    noResults: 'âŒ No voters found. Try adjusting the address or range'
  };
  
  function updateInstruction(step) {
    if (!instructionsToggle.checked) return;
    currentStep = step;
    instructionText.textContent = instructions[step] || instructions.street;
    console.log('ğŸ“‹ Instruction updated to:', step, 'â†’', instructions[step]);
  }
  
  // Toggle instructions panel
  instructionsToggle.addEventListener('change', () => {
    console.log('ğŸ›ï¸ Instructions toggle changed to:', instructionsToggle.checked);
    if (instructionsToggle.checked) {
      instructionsPanel.style.display = 'block';
      updateInstruction(currentStep);
      console.log('âœ… Instructions panel shown');
    } else {
      instructionsPanel.style.display = 'none';
      console.log('âŒ Instructions panel hidden');
    }
  });
  
  // Initialize with instructions enabled
  updateInstruction('street');
  
  // Add instruction event listeners to existing elements
  const streetInput = document.getElementById('street');
  const houseInput = document.getElementById('house');
  const btnFind = document.getElementById('btnFind');
  
  // Street field events
  streetInput.addEventListener('focus', () => {
    // Only update to streetFocused if we're at the initial street step
    // Don't revert if user has already selected a street
    if (currentStep === 'street' || (currentStep === 'streetFocused' && !streetInput.value.trim())) {
      updateInstruction('streetFocused');
    }
  });
  
  // We'll handle street selection in the dropdown click handler above
  // Only update instructions for manual typing if it's a reasonable length
  streetInput.addEventListener('input', () => {
    const value = streetInput.value.trim();
    if (value.length > 3) {
      // Only update if they've typed a substantial street name
      // This helps differentiate from dropdown selections
      setTimeout(() => {
        if (streetInput.value.trim() === value && value.length > 3) {
          updateInstruction('streetSelected');
        }
      }, 500); // Small delay to see if they're still typing
    }
  });
  
  // House field events  
  houseInput.addEventListener('focus', () => {
    if (!houseInput.disabled) {
      // Don't change instruction on focus, keep current state
    }
  });
  
  // We'll handle house selection in the dropdown click handler above
  // Only update for manual typing
  houseInput.addEventListener('input', () => {
    const value = houseInput.value.trim();
    if (value.length > 0) {
      setTimeout(() => {
        if (houseInput.value.trim() === value && value.length > 0) {
          updateInstruction('houseSelected');
        }
      }, 300);
    }
  });
  
  // Find button click
  btnFind.addEventListener('click', () => {
    updateInstruction('searching');
    // Results will be updated by monitoring the results div
  });
  
  // Monitor results div for changes
  const resultsDiv = document.getElementById('results');
  const observer = new MutationObserver(() => {
    if (instructionsToggle.checked) {
      const hasResults = resultsDiv.children.length > 0 && 
                        !resultsDiv.textContent.includes('No nearby addresses');
      if (hasResults) {
        updateInstruction('results');
      } else if (resultsDiv.textContent.includes('No nearby addresses')) {
        updateInstruction('noResults');
      }
    }
  });
  observer.observe(resultsDiv, { childList: true, subtree: true });
  
  const f = fromQS();
  showFiltersBadge(f);
  if (f.district_type && f.district) {
    preloadDistrictStreets(f);
  } else {
    setDistrictStreetsStatus('');
  }
  
  // ...existing code...
</script>
<script>
  (function () {
    const authInline = document.getElementById('authInline');
    if (!authInline) return;

    const render = state => {
      const email = state?.user?.email || null;
      if (state?.authenticated && email) {
        authInline.textContent = `Signed in as ${email}`;
        authInline.style.background = '#dcfce7';
        authInline.style.color = '#065f46';
      } else {
        authInline.textContent = 'Not signed in';
        authInline.style.background = '#fee2e2';
        authInline.style.color = '#991b1b';
      }
    };

    const bind = () => {
      const unsubscribe = window.authGlobal.onAuthChange(render);
      render(window.authGlobal);
      return unsubscribe;
    };

    if (window.authGlobal?.ready) {
      bind();
    } else {
      window.addEventListener(
        'authGlobalReady',
        () => {
          bind();
        },
        { once: true }
      );
    }
  })();
</script>
<script type="module">
  import { initHelpModal } from '../shared/helpModal.js';
  initHelpModal({
    helpPath: '/help/canvass.md',
    title: 'Canvass Instructions',
    toggleLabel: 'Help',
  });
</script>
