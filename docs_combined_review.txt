===== BEGIN ui/config/environments.js =====
/**
 * Environment detection and configuration system for GrassrootsMVT
 * Automatically detects localhost vs production and provides appropriate configuration
 */

class EnvironmentConfig {
  constructor() {
    this.environment = this.detectEnvironment();
    this.config = this.getConfigForEnvironment();
  }

  /**
   * Detect if running in local development or production
   * @returns {string} 'local' or 'production'
   */
  detectEnvironment() {
    if (typeof window !== 'undefined') {
      // Browser environment
      const hostname = window.location.hostname;
      const port = window.location.port;
      
      // Local development indicators
      if (hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('192.168.')) {
        return 'local';
      }
      
      // Common development ports
      if (port === '8788' || port === '8080' || port === '3000' || port === '5173') {
        return 'local';
      }
      
      // Production domains
      if (hostname.includes('grassrootsmvt.org') || hostname.includes('pages.dev')) {
        return 'production';
      }
    }
    
    // Node.js environment (for scripts)
    if (typeof process !== 'undefined' && process.env) {
      if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'local') {
        return 'local';
      }
      if (process.env.NODE_ENV === 'production') {
        return 'production';
      }
    }
    
    // Default to production for safety
    return 'production';
  }

  /**
   * Get configuration based on detected environment
   * @returns {object} Environment-specific configuration
   */
  getConfigForEnvironment() {
    const baseConfig = {
      environment: this.environment,
      isLocal: this.environment === 'local',
      isProduction: this.environment === 'production'
    };

    if (this.environment === 'local') {
      return {
        ...baseConfig,
        api: {
          baseUrl: 'http://localhost:8787',
          endpoints: {
            ping: '/api/ping',
            voters: '/api/voters',
            neighborhoods: '/api/neighborhoods',
            log: '/api/log',
            call: '/api/call',
            whoami: '/api/whoami',
            metadata: '/api/metadata',
            'contact-staging': '/api/contact-staging'
          }
        },
        ui: {
          baseUrl: 'http://localhost:8788',
          hostname: 'localhost:8788'
        },
        auth: {
          enabled: false,
          bypassAuthentication: true,
          testMode: true,
          mockUser: {
            email: 'dev@localhost',
            name: 'Local Developer'
          }
        },
        cors: {
          origin: 'http://localhost:8788',
          credentials: true
        },
        debug: {
          enabled: true,
          verbose: true,
          logLevel: 'debug'
        }
      };
    } else {
      return {
        ...baseConfig,
        api: {
          baseUrl: 'https://api.grassrootsmvt.org',
          endpoints: {
            ping: '/api/ping',
            voters: '/api/voters',
            neighborhoods: '/api/neighborhoods',
            log: '/api/log',
            call: '/api/call',
            whoami: '/api/whoami',
            metadata: '/api/metadata',
            'contact-staging': '/api/contact-staging'
          }
        },
        ui: {
          baseUrl: 'https://volunteers.grassrootsmvt.org',
          hostname: 'volunteers.grassrootsmvt.org'
        },
        auth: {
          enabled: true,
          bypassAuthentication: false,
          testMode: false,
          cloudflareAccess: {
            teamDomain: 'skovgard.cloudflareaccess.com',
            aud: '76fea0745afec089a3eddeba8d982b10aab6d6f871e43661cb4977765b78f3f0'
          }
        },
        cors: {
          origin: 'https://volunteers.grassrootsmvt.org',
          credentials: true
        },
        debug: {
          enabled: false,
          verbose: false,
          logLevel: 'warn'
        }
      };
    }
  }

  /**
   * Get API URL for a specific endpoint
   * @param {string} endpoint - Endpoint name (ping, voters, etc.)
   * @param {object} params - URL parameters
   * @returns {string} Full API URL
   */
  getApiUrl(endpoint, params = {}) {
    const baseUrl = this.config.api.baseUrl;
    // Look up endpoint path, or default to /api/ + endpoint
    const endpointPath = this.config.api.endpoints[endpoint] || 
                        (endpoint.startsWith('/') ? endpoint : `/api/${endpoint}`);
    
    let url = `${baseUrl}${endpointPath}`;
    
    // Add query parameters
    if (Object.keys(params).length > 0) {
      const searchParams = new URLSearchParams(params);
      url += `?${searchParams.toString()}`;
    }
    
    return url;
  }

  /**
   * Get UI URL with optional path
   * @param {string} path - Optional path to append
   * @returns {string} Full UI URL
   */
  getUiUrl(path = '') {
    return `${this.config.ui.baseUrl}${path}`;
  }

  /**
   * Check if authentication should be bypassed
   * @returns {boolean} True if auth should be bypassed
   */
  shouldBypassAuth() {
    return this.config.auth.bypassAuthentication;
  }

  /**
   * Get authentication configuration
   * @returns {object} Auth configuration
   */
  getAuthConfig() {
    return this.config.auth;
  }

  /**
   * Log debug message if debug is enabled
   * @param {string} message - Message to log
   * @param {any} data - Optional data to log
   */
  debug(message, data = null) {
    if (this.config.debug.enabled) {
      console.log(`[ENV-${this.environment.toUpperCase()}] ${message}`, data || '');
    }
  }

  /**
   * Log error message
   * @param {string} message - Error message
   * @param {any} error - Optional error object
   */
  error(message, error = null) {
    console.error(`[ENV-${this.environment.toUpperCase()}] ${message}`, error || '');
  }
}

// Global instance
const environmentConfig = new EnvironmentConfig();

// Export for different module systems
// ES6 modules (default export)
export default environmentConfig;

// CommonJS
if (typeof module !== 'undefined' && module.exports) {
  module.exports = environmentConfig;
}

// Global browser access
if (typeof window !== 'undefined') {
  window.environmentConfig = environmentConfig;
}

// Also expose the class for custom instances
if (typeof window !== 'undefined') {
  window.EnvironmentConfig = EnvironmentConfig;
}
===== END ui/config/environments.js =====

===== BEGIN worker/wrangler.toml =====
name = "grassrootsmvt"
main = "src/index.js"
compatibility_date = "2024-12-01"
compatibility_flags = ["nodejs_compat"]
# account_id = "<your-account-id>"

# ===== LOCAL =====
[[d1_databases]]
binding = "d1"
database_name = "wy_local"
database_id = "de78cb41-176d-40e8-bd3b-e053e347ac3f"
migrations_dir = "db/migrations"   # relative to worker/

[vars]
ENVIRONMENT = "local"
DATA_BACKEND = "d1"
ALLOW_ORIGIN_DEV = "http://127.0.0.1:8788,http://localhost:8788,http://localhost:5173"

# Serve static UI during local dev so UI and API share the same origin.
# The path is relative to this wrangler.toml file.

# ===== PREVIEW =====
[env.preview]
[env.preview.vars]
ENVIRONMENT = "preview"
DATA_BACKEND = "d1"
ALLOW_ORIGIN_DEV = "https://preview.grassrootsmvt.org"

[[env.preview.d1_databases]]
binding = "d1"
database_name = "wy_preview"
database_id = "de78cb41-176d-40e8-bd3b-e053e347ac3f"
migrations_dir = "db/migrations"   # relative to worker/

# ===== PRODUCTION =====
[env.production]
[env.production.vars]
ENVIRONMENT = "production"
DATA_BACKEND = "d1"
ALLOW_ORIGIN_DEV = "https://api.grassrootsmvt.org"

[[env.production.d1_databases]]
binding = "d1"
database_name = "wy"
database_id = "4b4227f1-bf30-4fcf-8a08-6967b536a5ab"
migrations_dir = "db/migrations"   # relative to worker/

# Production route: mount API under the same hostname as the UI.
# This assumes your zone is grassrootsmvt.org and the host is volunteers.grassrootsmvt.org.
# If routes already exist, add this entry without removing others.
routes = [
	{ pattern = "volunteers.grassrootsmvt.org/api/*", zone_name = "grassrootsmvt.org" }
]

===== END worker/wrangler.toml =====

===== BEGIN worker/src/index.js =====
// src/index.js ‚Äî Cloudflare Zero Trust module Worker
import { verifyAccessJWT } from "../functions/_utils/verifyAccessJWT.js";

// --- Environment Detection ---------------------------------------------------
function isLocalDevelopment(env) {
  // Primary check: explicit environment setting
  if (env.ENVIRONMENT === 'production') {
    return false;
  }
  
  // Check for local development indicators
  const hasLocalEnvVars = (
    env.ENVIRONMENT === 'local' ||
    env.ENVIRONMENT === 'development' ||
    env.LOCAL_DEVELOPMENT === 'true' ||
    env.DISABLE_AUTH === 'true'
  );
  
  // Detect wrangler dev environment by checking for production-specific vars
  // In production, these would be set; in local dev with wrangler dev, they're typically undefined
  const isWranglerDev = (
    typeof env.CF_ZONE_ID === 'undefined' && 
    typeof env.CF_ACCOUNT_ID === 'undefined' &&
    typeof env.CLOUDFLARE_ACCOUNT_ID === 'undefined'
  );
  
  return hasLocalEnvVars || isWranglerDev;
}

function getEnvironmentConfig(env) {
  const isLocal = isLocalDevelopment(env);
  
  return {
    environment: isLocal ? 'local' : 'production',
    isLocal: isLocal,
    auth: {
      enabled: !isLocal,
      bypassAuthentication: isLocal
    },
    allowedOrigins: parseAllowedOrigins(env),
    debug: isLocal
  };
}
// ---------------------------------------------------------------------------

// --- CORS helpers ------------------------------------------------------------
function parseAllowedOrigins(env) {
  const defaultOrigins = isLocalDevelopment(env)
    ? ["http://localhost:8788", "http://localhost:8080", "http://127.0.0.1:8788"]
    : ["https://volunteers.grassrootsmvt.org"];
  const envList = (env.ALLOW_ORIGIN || "")
    .split(",")
    .map(s => s.trim())
    .filter(Boolean);
  // If ALLOW_ORIGIN is set, use it exactly; otherwise fall back to defaults.
  return envList.length ? envList : defaultOrigins;
}

// Return the request's Origin only if it's allowed; otherwise null
function pickAllowedOrigin(request, env) {
  const reqOrigin = request.headers.get("Origin");
  if (!reqOrigin) return null;
  const allowed = parseAllowedOrigins(env);
  return allowed.includes(reqOrigin) ? reqOrigin : null;
}

function withCorsHeaders(headers, allowedOrigin) {
  const h = new Headers(headers || {});
  if (allowedOrigin) {
    h.set("Access-Control-Allow-Origin", allowedOrigin);
    h.set("Access-Control-Allow-Credentials", "true");
  }
  const vary = h.get("Vary");
  if (!vary) h.set("Vary", "Origin");
  else if (!/\bOrigin\b/i.test(vary)) h.set("Vary", vary + ", Origin");
  return h;
}

function preflightResponse(origin) {
  return new Response(null, {
    status: 204,
    headers: withCorsHeaders({
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type, Authorization, Cf-Access-Jwt-Assertion",
      "Access-Control-Max-Age": "86400",
      "Access-Control-Allow-Credentials": "true"
    }, origin)
  });
}
// ---------------------------------------------------------------------------

function getCookie(req, name) {
  const raw = req.headers.get("Cookie") || "";
  for (const part of raw.split(";")) {
    const [k, ...rest] = part.trim().split("=");
    if (k === name) return rest.join("=");
  }
  return null;
}

// Authentication middleware with local development bypass
async function authenticateRequest(request, env) {
  const config = getEnvironmentConfig(env);
  
  // Bypass authentication in local development
  if (config.auth.bypassAuthentication) {
    if (config.debug) {
      console.log('[LOCAL] Bypassing authentication - using mock user');
    }
    return {
      email: 'dev@localhost',
      name: 'Local Developer',
      isLocal: true
    };
  }
  
  // Production authentication via Cloudflare Access JWT
  return await verifyAccessJWT(request, env);
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    // Normalize /api/* to /* so both /auth/finish and /api/auth/finish work
    const normalizedPath = url.pathname.replace(/^\/api(?=\/|$)/, "");

    // ---- helpers ----------------------------------------------------------
    const getOrigin = () => request.headers.get("Origin") || "";

    // Read Access JWT from cookie first, then header as fallback
    function getAccessJwt(req) {
      const cookie = req.headers.get("Cookie") || "";
      const fromCookie = cookie.split(/;\s*/).find(x => x.startsWith("CF_Authorization="));
      if (fromCookie) {
        return decodeURIComponent(fromCookie.split("=", 2)[1] || "");
      }
      return req.headers.get("Cf-Access-Jwt-Assertion") || "";
    }

    async function verifyAccessJWTOrFail(req, env) {
      const jwt = getAccessJwt(req);
      if (!jwt) {
        throw new Error("Missing Access token");
      }
      // Use existing verifyAccessJWT utility
      const result = await verifyAccessJWT(req, env);
      return { ok: true, email: result.email, details: result };
    }

    const config = getEnvironmentConfig(env);
    const allowedOrigin = pickAllowedOrigin(request, env);
    
    // Debug logging for local development
    if (config.debug) {
      console.log(`[${config.environment.toUpperCase()}] ${request.method} ${url.pathname}`);
    }

    // Handle OPTIONS preflight early
    if (request.method === "OPTIONS") {
      return preflightResponse(allowedOrigin || null);
    }

    // Auth finish route - returns user to UI after Access login
    // Canonical finish endpoint: /auth/finish (and /api/auth/finish via normalization)
    if (normalizedPath === "/auth/finish") {
      const to = url.searchParams.get("to") || config.allowedOrigins[0] + "/";
      const html = `<!doctype html><meta charset="utf-8">
      <title>Returning‚Ä¶</title>
      <p>Returning to app‚Ä¶</p>
      <script>location.replace(${JSON.stringify(to)});</script>`;
      return new Response(html, { headers: { "Content-Type": "text/html; charset=utf-8" } });
    }

    // Logout: clear CF Access session and bounce back to UI
    if (normalizedPath === "/auth/logout") {
      const to = encodeURIComponent(url.searchParams.get("to") || config.allowedOrigins[0] + "/");
      const target = `https://api.grassrootsmvt.org/cdn-cgi/access/logout?return_to=${to}`;
      return Response.redirect(target, 302);
    }

    // Defensive catch: /auth/<encoded-destination> (only for actual encoded URLs, not query params)
    // This handles the mistaken UI redirect /api/auth/<encoded> but not /auth/finish?to=...
    if (normalizedPath.startsWith("/auth/") && normalizedPath !== "/auth/config" && !normalizedPath.startsWith("/auth/finish")) {
      const encoded = normalizedPath.slice("/auth/".length);
      // Only redirect if it looks like a URL (contains ://)
      if (encoded && (encoded.includes("%3A%2F%2F") || encoded.includes("://"))) {
        return Response.redirect(decodeURIComponent(encoded), 302);
      }
    }

    // Auth config route - returns environment-specific auth configuration
    if (normalizedPath === "/auth/config") {
      const authConfig = config.isLocal
        ? {
            environment: 'local',
            authRequired: false,
            teamDomain: null,
            policyAud: null
          }
        : {
            environment: 'production',
            authRequired: true,
            teamDomain: env.TEAM_DOMAIN,
            policyAud: env.POLICY_AUD
          };
      
      return new Response(JSON.stringify(authConfig), {
        headers: withCorsHeaders({
          "Content-Type": "application/json"
        }, allowedOrigin || null)
      });
    }

    // Tiny fast-path for the connecting probe
    if (normalizedPath === "/ping") {
      const finishUrl = url.searchParams.get("finish");
      
      // In local development, always return success
      if (config.isLocal) {
        if (finishUrl) {
          return Response.redirect(finishUrl, 302);
        }
        return new Response(JSON.stringify({
          ok: true,
          worker: "grassrootsmvt",
          environment: config.environment,
          timestamp: Date.now(),
          auth: 'bypassed'
        }), { 
          status: 200,
          headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
        });
      }
      
      // Production behavior - check for Access authentication
      const hasCfAuth = request.headers.get("Cookie")?.includes("CF_Authorization=");
      
      if (hasCfAuth && finishUrl) {
        // Already authenticated, redirect to finish URL
        return Response.redirect(finishUrl, 302);
      } else if (hasCfAuth) {
        // Already authenticated, normal ping response
        return new Response(JSON.stringify({
          ok: true,
          worker: "grassrootsmvt",
          environment: config.environment,
          timestamp: Date.now()
        }), { 
          status: 200,
          headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
        });
      }
      // else: fall through; Access will intercept and 302 to team domain.
    }

    // Error logging endpoint - public endpoint for debugging Access URL issues
    if (normalizedPath === "/error-log" && request.method === "POST") {
      try {
        const body = await request.json();
        const timestamp = new Date().toISOString();
        
        // Log to Cloudflare Worker console for immediate debugging
        console.log(`[ERROR-LOG ${timestamp}]`, JSON.stringify({
          sessionId: body.sessionId,
          logCount: body.logs?.length || 0,
          userAgent: body.meta?.userAgent,
          location: body.meta?.location,
          logs: body.logs || []
        }, null, 2));

        // Check for critical AUD-in-path patterns
        const audInPathLogs = (body.logs || []).filter(log => log.patterns?.isAudInPath);
        const status404Logs = (body.logs || []).filter(log => log.status === 404);
        
        if (audInPathLogs.length > 0) {
          console.error(`üö® CRITICAL: ${audInPathLogs.length} AUD-in-path URLs detected:`, audInPathLogs);
        }
        
        if (status404Logs.length > 0) {
          console.error(`üö® Access 404 errors detected:`, status404Logs);
        }

        return new Response(JSON.stringify({
          ok: true,
          received: body.logs?.length || 0,
          timestamp: timestamp,
          audInPathDetected: audInPathLogs.length,
          status404Detected: status404Logs.length
        }), {
          headers: withCorsHeaders({
            "Content-Type": "application/json"
          }, allowedOrigin || null)
        });
      } catch (error) {
        console.error('Error logging endpoint failed:', error);
        return new Response(JSON.stringify({
          ok: false,
          error: 'Failed to process error logs'
        }), {
          status: 500,
          headers: withCorsHeaders({
            "Content-Type": "application/json"
          }, allowedOrigin || null)
        });
      }
    }

    if (normalizedPath === "/whoami") {
      // Check for navigation parameter - this handles the unified auth flow
      const nav = url.searchParams.get("nav");
      const to = url.searchParams.get("to");
      if (nav === "1" && to) {
        // Top-level navigation path:
        //  - If already authenticated, 302 back to the UI.
        //  - If NOT authenticated, 302 to Cloudflare Access login (first-party),
        //    with redirect back to /whoami?nav=1&to=...
        try {
          const authResult = await authenticateRequest(request, env);
          if (authResult && authResult.email) {
            const dest = (() => {
              try {
                const u = new URL(to);
                // Only allow destinations whose origin is in our allowlist
                const ok = parseAllowedOrigins(env).includes(u.origin);
                return ok ? u.toString() : (parseAllowedOrigins(env)[0] + "/");
              } catch {
                return (parseAllowedOrigins(env)[0] + "/");
              }
            })();
            return Response.redirect(dest, 302);
          }
        } catch {}
        // Force an Access login challenge explicitly
        const team = env.TEAM_DOMAIN;   // e.g. https://<team>.cloudflareaccess.com
        const aud  = env.POLICY_AUD;    // your Access application AUD
        const back = encodeURIComponent(`/whoami?nav=1&to=${encodeURIComponent(to)}`);
        if (team && aud) {
          const login = `${team.replace(/\/+$/,'')}/cdn-cgi/access/login/api.grassrootsmvt.org?kid=${aud}&redirect_url=${back}`;
          return Response.redirect(login, 302);
        }
        // Fallback if env not set
        return new Response("Unauthorized", { status: 401 });
      }
      
      // Regular whoami API call (no navigation)
      try {
        const authResult = await authenticateRequest(request, env);
        if (!authResult || !authResult.email) {
          return new Response(JSON.stringify({ ok: false, error: "unauthorized" }), {
            status: 401,
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          });
        }
        return new Response(JSON.stringify({ 
          ok: true, 
          email: authResult.email,
          isLocal: authResult.isLocal || false
        }), {
          headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
        });
      } catch (err) {
        // In production: 401 so the UI can send the browser to /auth/finish
        return new Response(JSON.stringify({ 
          ok: false, 
          error: "unauthorized", 
          details: err.message 
        }), {
          status: 401,
          headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
        });
      }
    }

    // ÔøΩ Volunteer & Call Logging API

    if (normalizedPath === '/voters') {
      // Enhanced voter filtering with context-aware queries
      try {
        const db = env.d1;
        
        // Parse query parameters
        const city = url.searchParams.get('city');
        const houseDistrict = url.searchParams.get('house_district');
        const senateDistrict = url.searchParams.get('senate_district');
        
        console.log("Enhanced filters applied:", { city, houseDistrict, senateDistrict });
        
        let sql = '';
        let bindings = [];
        let filtersApplied = {
          city: city || null,
          house_district: houseDistrict || null,
          senate_district: senateDistrict || null,
          city_mode: null
        };
        
        // Enhanced conditional priority logic
        if (houseDistrict) {
          if (city && city.toUpperCase() !== "(ALL)") {
            // Voters in specific house district + specific city
            sql = `
              SELECT voter_id, political_party, county, house, senate
              FROM voters 
              WHERE house = ?1 AND county = ?2
              LIMIT 25
            `;
            bindings = [houseDistrict, city];
            filtersApplied.city_mode = 'specific';
          } else {
            // All voters in house district
            sql = `
              SELECT voter_id, political_party, county, house, senate
              FROM voters 
              WHERE house = ?1
              LIMIT 25
            `;
            bindings = [houseDistrict];
            filtersApplied.city_mode = city === '(ALL)' ? 'all' : 'district_only';
          }
        } else if (senateDistrict) {
          if (city && city.toUpperCase() !== "(ALL)") {
            // Voters in specific senate district + specific city
            sql = `
              SELECT voter_id, political_party, county, house, senate
              FROM voters 
              WHERE senate = ?1 AND county = ?2
              LIMIT 25
            `;
            bindings = [senateDistrict, city];
            filtersApplied.city_mode = 'specific';
          } else {
            // All voters in senate district
            sql = `
              SELECT voter_id, political_party, county, house, senate
              FROM voters 
              WHERE senate = ?1
              LIMIT 25
            `;
            bindings = [senateDistrict];
            filtersApplied.city_mode = city === '(ALL)' ? 'all' : 'district_only';
          }
        } else if (city) {
          // Voters by city only
          sql = `
            SELECT voter_id, political_party, county, house, senate
            FROM voters 
            WHERE county = ?1
            LIMIT 25
          `;
          bindings = [city];
          filtersApplied.city_mode = 'city_only';
        } else {
          // Default fallback - all voters
          sql = `
            SELECT voter_id, political_party, county, house, senate
            FROM voters 
            LIMIT 25
          `;
          bindings = [];
          filtersApplied.city_mode = 'fallback';
        }
        
        // Execute query
        const votersResult = await db.prepare(sql).bind(...bindings).all();
        
        // Get related cities for current selection (for UI context)
        let cities = [];
        try {
          if (houseDistrict || senateDistrict) {
            const districtField = houseDistrict ? 'house' : 'senate';
            const districtValue = houseDistrict || senateDistrict;
            
            const citiesResult = await db.prepare(`
              SELECT DISTINCT county FROM voters 
              WHERE ${districtField} = ?1 AND county IS NOT NULL AND county != ''
              ORDER BY county
            `).bind(districtValue).all();
            
            cities = ['(ALL)', ...(citiesResult.results?.map(r => r.county) || [])];
          }
        } catch (cityError) {
          console.warn('Failed to fetch related cities:', cityError);
        }

        return new Response(
          JSON.stringify({
            ok: true,
            filters_applied: filtersApplied,
            cities: cities,
            total: votersResult.results?.length || 0,
            voters: votersResult.results || []
          }),
          { 
            headers: withCorsHeaders({
              "Content-Type": "application/json",
              "Cache-Control": "max-age=120"
            }, allowedOrigin || null)
          }
        );
      } catch (error) {
        console.error('Enhanced voters query error:', error);
        return new Response(
          JSON.stringify({ 
            ok: false, 
            error: "query_failed", 
            message: error.message 
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null),
            status: 500 
          }
        );
      }
    }

    if (normalizedPath === '/call' && request.method === 'POST') {
      try {
        const user = await authenticateRequest(request, env);
        const email = user.email;
        const requestBody = await request.json();

        const db = env.d1;

        // Check if this is a request to get next voter (has filters) or log a call (has voter_id)
        if (requestBody.filters !== undefined || requestBody.exclude_ids !== undefined) {
          // Get next voter request
          const { filters = {}, exclude_ids = [] } = requestBody;
          
          // Build query to get next available voter using proper table joins
          let query = `SELECT v.voter_id, 
                              COALESCE(va.fn, '') as first_name, 
                              COALESCE(va.ln, '') as last_name, 
                              COALESCE(bp.phone_e164, '') as phone_1,
                              '' as phone_2,
                              v.county, 
                              COALESCE(va.city, '') as city, 
                              v.political_party
                       FROM voters v
                       LEFT JOIN voters_addr_norm va ON v.voter_id = va.voter_id
                       LEFT JOIN best_phone bp ON v.voter_id = bp.voter_id
                       WHERE 1=1`;
          const params = [];
          let paramIndex = 1;

          // Apply filters
          if (filters.county) {
            query += ` AND v.county = ?${paramIndex}`;
            params.push(filters.county);
            paramIndex++;
          }
          if (filters.city) {
            query += ` AND va.city = ?${paramIndex}`;
            params.push(filters.city);
            paramIndex++;
          }
          if (filters.parties && filters.parties.length > 0) {
            const partyPlaceholders = filters.parties.map(() => `?${paramIndex++}`).join(',');
            query += ` AND v.political_party IN (${partyPlaceholders})`;
            params.push(...filters.parties);
          }
          if (filters.require_phone) {
            query += ` AND (bp.phone_e164 IS NOT NULL AND bp.phone_e164 != '')`;
          }

          // Exclude already seen voters
          if (exclude_ids.length > 0) {
            const excludePlaceholders = exclude_ids.map(() => `?${paramIndex++}`).join(',');
            query += ` AND v.voter_id NOT IN (${excludePlaceholders})`;
            params.push(...exclude_ids);
          }

          query += ` ORDER BY RANDOM() LIMIT 1`;

          const result = await db.prepare(query).bind(...params).first();

          if (result) {
            return new Response(
              JSON.stringify({
                ok: true,
                voter_id: result.voter_id,
                first_name: result.first_name,
                last_name: result.last_name,
                phone_1: result.phone_1,
                phone_2: result.phone_2,
                county: result.county,
                city: result.city,
                political_party: result.political_party
              }),
              { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
            );
          } else {
            return new Response(
              JSON.stringify({
                ok: true,
                empty: true,
                message: 'No eligible voters found'
              }),
              { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
            );
          }
          
        } else {
          // Log call result request
          const { voter_id, call_result, notes } = requestBody;

          // Map to actual database schema: call_result -> outcome, notes -> payload_json
          await db.prepare(
            `INSERT INTO call_activity (ts, voter_id, volunteer_email, outcome, payload_json)
             VALUES (datetime('now'), ?1, ?2, ?3, ?4)`
          ).bind(voter_id, email, call_result || 'contacted', JSON.stringify({ notes: notes || '' })).run();

          return new Response(
            JSON.stringify({
              ok: true,
              message: 'Call logged successfully',
              volunteer: email
            }),
            { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
          );
        }

      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { status: 401, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      }
    }

    if (normalizedPath === '/canvass' && request.method === 'POST') {
      // Log canvassing activity from volunteer
      try {
        const user = await authenticateRequest(request, env);
        const email = user.email;
        const { 
          voter_id, 
          result, 
          notes, 
          pulse_opt_in, 
          pitch_used, 
          location_lat, 
          location_lng, 
          door_status, 
          followup_needed 
        } = await request.json();

        const db = env.d1;
        await db.prepare(
          `INSERT INTO canvass_activity 
           (voter_id, volunteer_email, result, notes, pulse_opt_in, pitch_used, location_lat, location_lng, door_status, followup_needed)
           VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)`
        ).bind(
          voter_id, 
          email, 
          result, 
          notes, 
          pulse_opt_in || false, 
          pitch_used, 
          location_lat, 
          location_lng, 
          door_status, 
          followup_needed || false
        ).run();

        return new Response(
          JSON.stringify({
            ok: true,
            message: 'Canvass logged successfully',
            voter_id: voter_id,
            volunteer: email
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: error.message.includes('JWT') ? 401 : 500, 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/streets' && request.method === 'POST') {
      // Get all unique streets for a county/city combination - optimized for autocomplete
      try {
        const user = await authenticateRequest(request, env);
        const { county, city } = await request.json();

        if (!county || !city) {
          return new Response(
            JSON.stringify({ ok: false, error: 'county and city are required' }),
            { status: 400, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
          );
        }

        const db = env.d1;
        
        // Optimized query to get all unique streets for a county/city
        // Extract street name by removing house number from addr1
        const streetsQuery = `
          SELECT DISTINCT 
                 UPPER(TRIM(SUBSTR(va.addr1, INSTR(va.addr1, ' ') + 1))) as street_name,
                 COUNT(*) as voter_count
          FROM voters v
          JOIN voters_addr_norm va ON v.voter_id = va.voter_id
          WHERE v.county = ?1 
            AND va.city = ?2
            AND va.addr1 IS NOT NULL 
            AND va.addr1 != ''
            AND INSTR(va.addr1, ' ') > 0
            AND LENGTH(TRIM(SUBSTR(va.addr1, INSTR(va.addr1, ' ') + 1))) > 0
          GROUP BY UPPER(TRIM(SUBSTR(va.addr1, INSTR(va.addr1, ' ') + 1)))
          ORDER BY street_name
        `;

        const result = await db.prepare(streetsQuery).bind(county, city).all();
        
        const streets = (result.results || []).map(row => ({
          name: row.street_name,
          count: row.voter_count
        }));

        return new Response(
          JSON.stringify({
            ok: true,
            county: county,
            city: city,
            streets: streets,
            total: streets.length
          }),
          { 
            headers: withCorsHeaders({ 
              "Content-Type": "application/json",
              "Cache-Control": "max-age=3600" // Cache for 1 hour since streets don't change often
            }, allowedOrigin || null)
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: error.message.includes('JWT') ? 401 : 500, 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/canvass/nearby' && request.method === 'POST') {
      // Find nearby addresses for door-to-door canvassing
      try {
        const user = await authenticateRequest(request, env);
        const { filters = {}, house, street, range = 20, limit = 20 } = await request.json();

        const db = env.d1;
        
        // Build query to find voters on the same street within house number range
        let query = `SELECT v.voter_id, 
                            COALESCE(va.fn, '') as first_name, 
                            COALESCE(va.ln, '') as last_name, 
                            COALESCE(va.addr1, '') as address,
                            COALESCE(va.city, '') as city, 
                            COALESCE(va.zip, '') as zip,
                            v.county, 
                            v.political_party as party,
                            COALESCE(bp.phone_e164, '') as phone_e164,
                            bp.confidence_code as phone_confidence
                     FROM voters v
                     LEFT JOIN voters_addr_norm va ON v.voter_id = va.voter_id
                     LEFT JOIN best_phone bp ON v.voter_id = bp.voter_id
                     WHERE 1=1`;
        const params = [];
        let paramIndex = 1;

        // Apply geographic filters
        if (street) {
          query += ` AND UPPER(va.addr1) LIKE '%' || ?${paramIndex} || '%'`;
          params.push(street.toUpperCase());
          paramIndex++;
        }

        // Apply demographic filters from URL parameters
        if (filters.county) {
          query += ` AND v.county = ?${paramIndex}`;
          params.push(filters.county);
          paramIndex++;
        }
        if (filters.parties && filters.parties.length > 0) {
          const partyPlaceholders = filters.parties.map(() => `?${paramIndex++}`).join(',');
          query += ` AND v.political_party IN (${partyPlaceholders})`;
          params.push(...filters.parties);
        }

        // If house number is provided, try to find nearby house numbers
        if (house && range) {
          query += ` AND va.addr1 IS NOT NULL AND va.addr1 != ''`;
          // This is a simplified approach - in production you'd want more sophisticated address parsing
        }

        query += ` ORDER BY v.voter_id LIMIT ?${paramIndex}`;
        params.push(Math.min(limit, 100)); // Cap at 100 for performance

        const result = await db.prepare(query).bind(...params).all();
        
        // Format results for canvass UI
        const rows = (result.results || []).map(row => ({
          voter_id: row.voter_id,
          name: [row.first_name, row.last_name].filter(Boolean).join(' ') || 'Unknown',
          address: row.address || 'Address unknown',
          city: row.city || '',
          zip: row.zip || '',
          party: row.party || '',
          phone_e164: row.phone_e164 || null,
          phone_confidence: row.phone_confidence || null
        }));

        return new Response(
          JSON.stringify({
            ok: true,
            rows: rows,
            total: rows.length,
            filters_applied: filters
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: error.message.includes('JWT') ? 401 : 500, 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/complete' && request.method === 'POST') {
      // Enhanced call/canvass completion endpoint with email collection
      try {
        const user = await authenticateRequest(request, env);
        const email = user.email;
        const callData = await request.json();
        
        console.log('üìû Received call completion data:', callData);
        
        const {
          voter_id,
          outcome,
          ok_callback = false,
          requested_info = false,
          dnc = false,
          best_day = null,
          best_time_window = null,
          optin_sms = false,
          optin_email = false,
          email: voterEmail = null,
          wants_volunteer = false,
          share_insights_ok = false,
          for_term_limits = false,
          issue_public_lands = false,
          comments = null
        } = callData;

        // Map frontend outcome values to database result values
        const resultMap = {
          'connected': 'Contacted',
          'vm': 'Contacted',
          'no_answer': 'Not Home', 
          'wrong_number': 'Wrong Number',
          'refused': 'Refused',
          'follow_up': 'Follow Up',
          'dnc': 'Do Not Contact'
        };
        
        const mappedResult = resultMap[outcome] || 'Contacted';

        const db = env.d1;
        
        // Log in canvass_activity for backwards compatibility
        await db.prepare(
          `INSERT INTO canvass_activity 
           (voter_id, volunteer_email, result, notes, pulse_opt_in, created_at)
           VALUES (?1, ?2, ?3, ?4, ?5, datetime('now'))`
        ).bind(
          voter_id, 
          email, 
          mappedResult, 
          comments || '', 
          (optin_email || optin_sms) ? 1 : 0
        ).run();

        // If email is provided, store it in the voter_emails table
        if (voterEmail && voterEmail.trim()) {
          try {
            await db.prepare(`
              INSERT OR REPLACE INTO voter_emails (
                voter_id, email, email_verified, opt_in_status, source, collected_by, collected_at, last_updated
              ) VALUES (
                ?1, ?2, 0, ?3, 'phone_call', ?4, datetime('now'), datetime('now')
              )
            `).bind(
              voter_id,
              voterEmail.trim(),
              optin_email ? 'opted_in' : 'unknown',
              email
            ).run();
            console.log('üìß Email stored in voter_emails table from call:', voterEmail);
          } catch (emailError) {
            console.warn('Failed to store email in voter_emails table:', emailError);
            // Continue execution - don't fail the whole call if email storage fails
          }
        }

        return new Response(
          JSON.stringify({
            ok: true,
            message: 'Call completed successfully',
            voter_id: voter_id,
            volunteer: email,
            outcome: outcome,
            email_collected: !!voterEmail
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: error.message.includes('JWT') ? 401 : 500, 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/contact-staging' && request.method === 'POST') {
      // NEW: Handle new voter contact submissions for staging system
      try {
        const user = await authenticateRequest(request, env);
        const volunteer_email = user.email;
        const contactData = await request.json();
        
        console.log('üìù Received staging contact data:', contactData);
        
        const {
          county,
          city,
          streetName,
          houseNumber,
          firstName,
          lastName,
          middleName,
          suffix,
          fullAddress,
          unitNumber,
          zipCode,
          phonePrimary,
          email,
          estimatedParty,
          votingLikelihood,
          contactMethod,
          interactionNotes,
          issuesInterested,
          volunteerNotes
        } = contactData;

        // Validate required fields for staging
        if (!county || !city || !firstName || !lastName) {
          return new Response(
            JSON.stringify({ ok: false, error: 'county, city, firstName, and lastName are required' }),
            { status: 400, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
          );
        }

        const db = env.d1;
        
        // Insert into voter_contact_staging table
        const result = await db.prepare(`
          INSERT INTO voter_contact_staging (
            submitted_by, vol_email, search_county, search_city, search_street_name, search_house_number,
            fn, ln, middle_name, suffix, addr1, house_number, street_name, unit_number,
            city, county, state, zip, phone_e164, email, political_party, voting_likelihood,
            contact_method, interaction_notes, issues_interested, volunteer_notes, created_at
          ) VALUES (
            ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17, ?18, ?19, ?20, ?21, ?22, ?23, ?24, ?25, ?26, datetime('now')
          )
        `).bind(
          volunteer_email,
          volunteer_email,
          county,
          city,
          streetName || '',
          houseNumber || '',
          firstName,
          lastName,
          middleName || '',
          suffix || '',
          fullAddress || `${houseNumber || ''} ${streetName || ''}`.trim(),
          houseNumber || '',
          streetName || '',
          unitNumber || '',
          city,
          county,
          'WY',
          zipCode || '',
          phonePrimary || '',
          email || '',
          estimatedParty || '',
          votingLikelihood || 'unknown',
          contactMethod || 'door',
          interactionNotes || '',
          issuesInterested || '',
          volunteerNotes || ''
        ).run();

        return new Response(
          JSON.stringify({
            ok: true,
            message: 'Contact submitted to staging successfully',
            staging_id: result.meta.last_row_id,
            volunteer: volunteer_email,
            status: 'pending_verification'
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        console.error('Error submitting staging contact:', error);
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: 500,
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/contact' && request.method === 'POST') {
      // Enhanced contact recording with rich data collection (for existing voters)
      try {
        const user = await authenticateRequest(request, env);
        const volunteer_email = user.email;
        const contactData = await request.json();
        
        console.log('üìã Received contact data:', contactData);
        
        const {
          voter_id,
          method = 'door',
          outcome,
          wants_volunteer = false,
          wants_updates = false,
          ok_callback = false,
          requested_info = false,
          email = null,
          optin_email = false,
          optin_sms = false,
          for_term_limits = false,
          issue_public_lands = false,
          comments = null
        } = contactData;

        // Validate required fields
        if (!voter_id || !outcome) {
          return new Response(
            JSON.stringify({ ok: false, error: 'voter_id and outcome are required' }),
            { status: 400, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
          );
        }

        const db = env.d1;
        
        // Insert into voter_contacts table with rich data
        await db.prepare(`
          INSERT INTO voter_contacts (
            voter_id, volunteer_id, method, outcome,
            ok_callback, requested_info, dnc, 
            optin_sms, optin_email, email,
            wants_volunteer, for_term_limits, issue_public_lands,
            comments, created_at
          ) VALUES (
            ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, datetime('now')
          )
        `).bind(
          voter_id,
          volunteer_email,
          method,
          outcome,
          ok_callback ? 1 : 0,
          requested_info ? 1 : 0,
          outcome === 'dnc' ? 1 : 0, // Set DNC flag if outcome is dnc
          optin_sms ? 1 : 0,
          optin_email ? 1 : 0,
          email,
          wants_volunteer ? 1 : 0,
          for_term_limits ? 1 : 0,
          issue_public_lands ? 1 : 0,
          comments
        ).run();

        // If email is provided, store it in the voter_emails table
        if (email && email.trim()) {
          try {
            await db.prepare(`
              INSERT OR REPLACE INTO voter_emails (
                voter_id, email, email_verified, opt_in_status, source, collected_by, collected_at, last_updated
              ) VALUES (
                ?1, ?2, 0, ?3, 'contact_form', ?4, datetime('now'), datetime('now')
              )
            `).bind(
              voter_id,
              email.trim(),
              optin_email ? 'opted_in' : 'unknown',
              volunteer_email
            ).run();
            console.log('üìß Email stored in voter_emails table:', email);
          } catch (emailError) {
            console.warn('Failed to store email in voter_emails table:', emailError);
            // Continue execution - don't fail the whole contact if email storage fails
          }
        }

        // Also log in canvass_activity for backwards compatibility
        const resultMap = {
          'connected': 'Contacted',
          'brief': 'Contacted',
          'info_left': 'Contacted',
          'not_interested': 'Contacted',
          'no_answer': 'Not Home',
          'refused': 'Refused',
          'wrong_address': 'Moved',
          'dnc': 'Do Not Contact'
        };
        
        const mappedResult = resultMap[outcome] || 'Contacted';
        
        await db.prepare(
          `INSERT INTO canvass_activity 
           (voter_id, volunteer_email, result, notes, pulse_opt_in, created_at)
           VALUES (?1, ?2, ?3, ?4, ?5, datetime('now'))`
        ).bind(
          voter_id, 
          volunteer_email, 
          mappedResult, 
          comments || '', 
          (optin_email || optin_sms) ? 1 : 0
        ).run();

        return new Response(
          JSON.stringify({
            ok: true,
            message: 'Contact recorded successfully',
            voter_id: voter_id,
            volunteer: volunteer_email,
            outcome: outcome,
            rich_data_captured: true
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        console.error('Error recording contact:', error);
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: 500,
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/contact/status' && request.method === 'GET') {
      // Get contact status for voters (for canvass page display)
      try {
        const user = await authenticateRequest(request, env);
        const voter_ids = url.searchParams.get('voter_ids')?.split(',') || [];
        
        if (!voter_ids.length || voter_ids.length > 50) {
          return new Response(
            JSON.stringify({ ok: false, error: 'voter_ids parameter required (max 50 IDs)' }),
            { status: 400, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
          );
        }

        const db = env.d1;
        
        // Get latest contact for each voter from both tables
        const placeholders = voter_ids.map(() => '?').join(',');
        
        // Query voter_contacts for rich contact data
        const contactQuery = `
          SELECT 
            voter_id,
            volunteer_id as volunteer_email,
            method,
            outcome,
            created_at,
            'voter_contacts' as source
          FROM voter_contacts 
          WHERE voter_id IN (${placeholders})
          ORDER BY created_at DESC
        `;
        
        // Query canvass_activity for basic contact data
        const canvassQuery = `
          SELECT 
            voter_id,
            volunteer_email,
            'door' as method,
            result as outcome,
            created_at,
            'canvass_activity' as source
          FROM canvass_activity 
          WHERE voter_id IN (${placeholders})
          ORDER BY created_at DESC
        `;
        
        const [contactResults, canvassResults] = await Promise.all([
          db.prepare(contactQuery).bind(...voter_ids).all(),
          db.prepare(canvassQuery).bind(...voter_ids).all()
        ]);
        
        // Combine and find latest contact per voter
        const allContacts = [...contactResults.results, ...canvassResults.results];
        const latestContacts = {};
        
        for (const contact of allContacts) {
          const voterId = contact.voter_id;
          if (!latestContacts[voterId] || contact.created_at > latestContacts[voterId].created_at) {
            latestContacts[voterId] = contact;
          }
        }
        
        return new Response(
          JSON.stringify({
            ok: true,
            contacts: latestContacts
          }),
          { headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
        
      } catch (error) {
        console.error('Error fetching contact status:', error);
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: error.message.includes('JWT') ? 401 : 500,
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/pulse' && request.method === 'POST') {
      // Track pulse opt-ins (text/email consent)
      try {
        const { voter_id, contact_method, consent_source } = await request.json();
        
        // Volunteer email is optional for this endpoint
        let volunteer_email = null;
        try {
          const user = await authenticateRequest(request, env);
          volunteer_email = user.email;
        } catch (authError) {
          // Continue without volunteer email if auth fails (for public forms)
          if (config.debug) {
            console.log('No authentication provided for pulse opt-in, continuing without volunteer email');
          }
        }

        const db = env.d1;
        
        // First delete any existing record for this voter_id + contact_method
        await db.prepare(
          `DELETE FROM pulse_optins WHERE voter_id = ?1 AND contact_method = ?2`
        ).bind(voter_id, contact_method).run();
        
        // Then insert the new record
        await db.prepare(
          `INSERT INTO pulse_optins 
           (voter_id, contact_method, consent_given, consent_source, volunteer_email, created_at)
           VALUES (?1, ?2, 1, ?3, ?4, datetime('now'))`
        ).bind(voter_id, contact_method, consent_source, volunteer_email).run();

        return new Response(
          JSON.stringify({
            ok: true,
            message: 'Pulse opt-in recorded',
            voter_id: voter_id,
            method: contact_method
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { 
            status: 500, 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
          }
        );
      }
    }

    if (normalizedPath === '/activity') {
      // Return recent call activity by authenticated volunteer
      try {
        const user = await authenticateRequest(request, env);
        const email = user.email;

        const db = env.d1;
        const result = await db.prepare(
          `SELECT * FROM call_activity WHERE volunteer_email = ?1 ORDER BY ts DESC LIMIT 10;`
        ).bind(email).all();

        return new Response(
          JSON.stringify({ ok: true, activity: result.results || [] }),
          { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({ ok: false, error: error.message }),
          { status: 401, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      }
    }

    // üìç Geographic Metadata for Forms with Enhanced District‚ÜîCity Logic
    if (normalizedPath === '/metadata') {
      try {
        const db = env.d1;
        
        // Parse query parameters for smart mode detection
        const city = url.searchParams.get('city'); // This will be treated as county
        const houseDistrict = url.searchParams.get('house_district');
        const senateDistrict = url.searchParams.get('senate_district');
        
        // DISTRICT‚ÜíCOUNTY MODE: User selects district, get counties in that district
        if (houseDistrict || senateDistrict) {
          const districtField = houseDistrict ? 'house' : 'senate';
          const districtValue = houseDistrict || senateDistrict;
          const districtType = houseDistrict ? 'house_district' : 'senate_district';
          
          console.log(`District‚ÜíCounty mode: querying counties for ${districtType}=${districtValue}`);
          
          const countiesResult = await db.prepare(`
            SELECT DISTINCT county FROM voters 
            WHERE ${districtField} = ?1 AND county IS NOT NULL AND county != ''
            ORDER BY county
          `).bind(districtValue).all();
          
          const counties = countiesResult.results?.map(r => r.county) || [];
          
          // Always include "(ALL)" as first option, then sorted counties
          const countiesWithAll = ['(ALL)', ...counties];
          
          return new Response(
            JSON.stringify({
              ok: true,
              mode: "district_to_city",
              [districtType]: districtValue,
              district: districtValue,
              cities: countiesWithAll  // Using 'cities' for API consistency
            }),
            { 
              headers: withCorsHeaders({
                "Content-Type": "application/json",
                "Cache-Control": "max-age=86400"
              }, allowedOrigin || null)
            }
          );
        }
        
        // COUNTY‚ÜíDISTRICT MODE: User selects county, get districts in that county
        if (city) {
          console.log(`County‚ÜíDistrict mode: querying districts for county=${city}`);
          
          const [houseResult, senateResult] = await Promise.all([
            db.prepare(`
              SELECT DISTINCT house FROM voters 
              WHERE county = ?1 AND house IS NOT NULL AND house != ''
              ORDER BY CAST(house AS INTEGER)
            `).bind(city).all(),
            
            db.prepare(`
              SELECT DISTINCT senate FROM voters 
              WHERE county = ?1 AND senate IS NOT NULL AND senate != ''
              ORDER BY CAST(senate AS INTEGER)
            `).bind(city).all()
          ]);
          
          const houseDistricts = houseResult.results?.map(r => r.house) || [];
          const senateDistricts = senateResult.results?.map(r => r.senate) || [];
          
          return new Response(
            JSON.stringify({
              ok: true,
              mode: "city_to_district",
              city: city,
              house_districts: houseDistricts,
              senate_districts: senateDistricts
            }),
            { 
              headers: withCorsHeaders({
                "Content-Type": "application/json",
                "Cache-Control": "max-age=86400"
              }, allowedOrigin || null)
            }
          );
        }
        
        // DEFAULT MODE: No specific parameters, return all metadata
        const [counties, houseDistricts, senateDistricts] = await Promise.all([
          db.prepare(`
            SELECT DISTINCT county FROM voters 
            WHERE county IS NOT NULL AND county != '' 
            ORDER BY county
          `).all(),
          
          db.prepare(`
            SELECT DISTINCT house FROM voters 
            WHERE house IS NOT NULL AND house != '' 
            ORDER BY CAST(house AS INTEGER)
          `).all(),
          
          db.prepare(`
            SELECT DISTINCT senate FROM voters 
            WHERE senate IS NOT NULL AND senate != '' 
            ORDER BY CAST(senate AS INTEGER)
          `).all()
        ]);

        return new Response(
          JSON.stringify({
            ok: true,
            mode: "default",
            state: "WY",
            counties: counties.results?.map(r => r.county) || [],
            cities: counties.results?.map(r => r.county) || [], // For API consistency
            house_districts: houseDistricts.results?.map(r => r.house) || [],
            senate_districts: senateDistricts.results?.map(r => r.senate) || [],
            auto_populate: false
          }),
          { 
            headers: withCorsHeaders({
              "Content-Type": "application/json",
              "Cache-Control": "max-age=86400"
            }, allowedOrigin || null)
          }
        );
      } catch (error) {
        // Fallback with static Wyoming data if D1 query fails
        return new Response(
          JSON.stringify({
            ok: false,
            error: "metadata_query_failed",
            message: error.message,
            state: "WY",
            counties: ["ALBANY", "BIG HORN", "CAMPBELL", "CARBON", "CONVERSE", "CROOK", 
                      "FREMONT", "GOSHEN", "HOT SPRINGS", "JOHNSON", "LARAMIE", "LINCOLN",
                      "NATRONA", "NIOBRARA", "PARK", "PLATTE", "SHERIDAN", "SUBLETTE",
                      "SWEETWATER", "TETON", "UINTA", "WASHAKIE", "WESTON"],
            house_districts: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10",
                             "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
                             "21", "22", "23", "24", "25", "26", "27", "28", "29", "30",
                             "31", "32", "33", "34", "35", "36", "37", "38", "39", "40",
                             "41", "42", "43", "44", "45", "46", "47", "48", "49", "50",
                             "51", "52", "53", "54", "55", "56", "57", "58", "59", "60"],
            senate_districts: ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10",
                              "11", "12", "13", "14", "15", "16", "17", "18", "19", "20",
                              "21", "22", "23", "24", "25", "26", "27", "28", "29", "30"]
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null),
            status: 500
          }
        );
      }
    }

    // ÔøΩ Message Templates API
    if (normalizedPath === '/templates') {
      try {
        const db = env.d1;
        const category = url.searchParams.get('category');
        
        let sql = `
          SELECT id, title, category, body_text
          FROM message_templates
          WHERE is_active = 1
        `;
        let bindings = [];
        
        if (category) {
          sql += ` AND category = ?1`;
          bindings = [category];
        }
        
        sql += ` ORDER BY id`;
        
        const result = await db.prepare(sql).bind(...bindings).all();

        return new Response(
          JSON.stringify({
            ok: true,
            templates: result.results || []
          }),
          { 
            headers: withCorsHeaders({
              "Content-Type": "application/json",
              "Cache-Control": "max-age=300"
            }, allowedOrigin || null)
          }
        );
      } catch (error) {
        console.error('Templates query error:', error);
        return new Response(
          JSON.stringify({ 
            ok: false, 
            error: "templates_query_failed", 
            message: error.message 
          }),
          { 
            headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null),
            status: 500 
          }
        );
      }
    }

    // ÔøΩüóÑÔ∏è List D1 Tables
    if (normalizedPath === '/db/tables') {
      try {
        const db = env.d1;
        if (!db) throw new Error('No D1 binding available. Check wrangler.toml.');

        const result = await db.prepare(
          "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name;"
        ).all();

        return new Response(
          JSON.stringify({
            ok: true,
            tables: result.results || [],
            environment: env.ENVIRONMENT || 'unknown'
          }),
          { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      } catch (error) {
        console.error('DB Error:', error);
        return new Response(
          JSON.stringify({
            ok: false,
            error: error.message,
            environment: env.ENVIRONMENT || 'unknown'
          }),
          { status: 500, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      }
    }

    // üîç Check table schema
    if (normalizedPath === '/db/schema' && url.searchParams.get('table')) {
      try {
        const db = env.d1;
        const tableName = url.searchParams.get('table');
        
        const result = await db.prepare(
          `PRAGMA table_info(${tableName});`
        ).all();

        return new Response(
          JSON.stringify({
            ok: true,
            table: tableName,
            columns: result.results || [],
            environment: env.ENVIRONMENT || 'unknown'
          }),
          { status: 200, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({
            ok: false,
            error: error.message,
            environment: env.ENVIRONMENT || 'unknown'
          }),
          { status: 500, headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null) }
        );
      }
    }

    return new Response(JSON.stringify({ ok: false, error: "Not Found" }), {
      status: 404,
      headers: withCorsHeaders({ "Content-Type": "application/json" }, allowedOrigin || null)
    });
  }
};

===== END worker/src/index.js =====

===== BEGIN ui/src/apiClient.js =====
/**
 * GrassrootsMVT API Client with Enhanced Authentication Handling
 */

// Environment configuration - try different ways to access it
let environmentConfig;

// Wait for environment config to be available if needed
async function ensureEnvironmentConfig() {
  if (!environmentConfig && typeof window !== 'undefined') {
    // Wait a bit for the global variable to be set
    await new Promise(resolve => setTimeout(resolve, 100));
    if (window.environmentConfig) {
      environmentConfig = window.environmentConfig;
    }
  }
  
  // If still no environment config, make sure fallback is properly configured
  if (!environmentConfig) {
    environmentConfig = {
      shouldBypassAuth: () => {
        // Simple localhost detection fallback
        return location.hostname === 'localhost' || location.hostname === '127.0.0.1';
      },
      getApiUrl: (endpoint, params = {}) => {
        const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        const baseUrl = isLocal ? 'http://localhost:8787' : 'https://api.grassrootsmvt.org';
        
        // Handle endpoint mapping like the real environment config
        const endpointMap = {
          'ping': '/api/ping',
          'voters': '/api/voters',
          'neighborhoods': '/api/neighborhoods',
          'log': '/api/log',
          'call': '/api/call',
          'whoami': '/api/whoami'
        };
        
        const endpointPath = endpointMap[endpoint] || (endpoint.startsWith('/') ? endpoint : `/api/${endpoint}`);
        let url = `${baseUrl}${endpointPath}`;
        
        if (Object.keys(params).length > 0) {
          const searchParams = new URLSearchParams(params);
          url += `?${searchParams.toString()}`;
        }
        return url;
      },
      debug: (message, data) => {
        const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
        if (isLocal) {
          console.log(`[ENV-LOCAL-FALLBACK] ${message}`, data || '');
        }
      },
      config: {
        environment: location.hostname === 'localhost' ? 'local' : 'production',
        isLocal: location.hostname === 'localhost' || location.hostname === '127.0.0.1'
      }
    };
  }
  
  return environmentConfig;
}

const API_ORIGIN = (() => {
  const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  return isLocal ? 'http://localhost:8787' : 'https://api.grassrootsmvt.org';
})();

const API_BASE = `${API_ORIGIN}/api`;

// Unified keys used everywhere
const ACCESS_READY_KEY   = "accessReady:v1";
const REDIRECT_GUARD_KEY = "access:redirected";

// Small safety to prevent open-redirects: only allow same-origin destinations
function safeTo(urlString) {
  try {
    const dest = new URL(urlString, window.location.href);
    const here = new URL(window.location.href);
    if (dest.origin !== here.origin) {
      // if different origin, fall back to site root
      return `${here.origin}/`;
    }
    return dest.toString();
  } catch { return window.location.origin + "/"; }
}

async function withAuthHeaders(init = {}) {
  const headers = new Headers(init.headers || {});
  if (!headers.has("Content-Type")) headers.set("Content-Type", "application/json");
  // include cookies so CF Access session is sent
  return { ...init, headers, credentials: "include" };
}

async function apiGet(path) {
  const res = await fetch(`${API_BASE}${path}`, await withAuthHeaders());
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    const err = new Error(`GET ${path} ${res.status}`);
    err.status = res.status;
    err.body = text;
    throw err;
  }
  return res.json();
}

async function apiPost(path, body) {
  const res = await fetch(
    `${API_BASE}${path}`,
    await withAuthHeaders({ method: "POST", body: JSON.stringify(body || {}) })
  );
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    const err = new Error(`POST ${path} ${res.status}`);
    err.status = res.status;
    err.body = text;
    throw err;
  }
  return res.json();
}

// Call this once during app bootstrap OR before showing identity
async function getCurrentUserOrRedirect() {
  // If we just returned from Access and whoami succeeds, mark ready and clear guard.
  try {
    const who = await apiGet("/whoami");
    sessionStorage.setItem(ACCESS_READY_KEY, "true");
    sessionStorage.removeItem(REDIRECT_GUARD_KEY);
    return who;
  } catch (e) {
    if (e.status === 401) {
      // Respect older bootstrap flag if present, to avoid double-redirects
      const bootstrapReady = sessionStorage.getItem(ACCESS_READY_KEY) === "true";
      const already        = sessionStorage.getItem(REDIRECT_GUARD_KEY) === "1";

      // Only one top-level navigation attempt per load, and only if not already "ready"
      if (!bootstrapReady && !already) {
        sessionStorage.setItem(REDIRECT_GUARD_KEY, "1");
        const to = encodeURIComponent(safeTo(window.location.href));
        // Use WHOAMI nav flow so Access becomes first-party and sets its cookie
        window.location.href = `${API_ORIGIN}/whoami?nav=1&to=${to}`;
        return new Promise(() => {}); // halt while navigating
      }

      // If we get here: we either already tried once, or bootstrap claimed ready.
      // Surface a visible banner rather than looping.
      console.error("Auth still not established after redirect.");
      const banner = document.getElementById("auth-banner") || document.createElement("div");
      banner.id = "auth-banner";
      banner.style.cssText = "position:fixed;top:0;left:0;right:0;padding:10px;background:#ffe0e0;color:#900;font-weight:600;z-index:99999";
      banner.textContent = "Login did not stick. Click to finish sign-in.";
      banner.onclick = () => {
        const to = encodeURIComponent(safeTo(window.location.href));
        window.location.href = `${API_ORIGIN}/whoami?nav=1&to=${to}`;
      };
      if (!banner.isConnected) document.body.appendChild(banner);
      throw e;
    }
    throw e;
  }
}

// Legacy compatibility - maintain existing function names for backward compatibility
async function ensureAccessSession() {
  const envConfig = await ensureEnvironmentConfig();
  
  // Bypass authentication in local development
  if (envConfig.shouldBypassAuth()) {
    envConfig.debug('Bypassing authentication in local development');
    sessionStorage.setItem(ACCESS_READY_KEY, 'true');
    return Promise.resolve();
  }

  const ready = sessionStorage.getItem(ACCESS_READY_KEY) === 'true';
  if (!ready) {
    // Use the new getCurrentUserOrRedirect method
    try {
      await getCurrentUserOrRedirect();
      sessionStorage.setItem(ACCESS_READY_KEY, 'true');
    } catch (err) {
      // getCurrentUserOrRedirect handles redirect, so this shouldn't normally execute
      const returnTo = encodeURIComponent(safeTo(location.href));
      window.location.href = `${API_ORIGIN}/whoami?nav=1&to=${returnTo}`;
      return new Promise(() => {});
    }
  }
  return Promise.resolve();
}

// Centralized API fetch with credentials
async function apiFetch(path, options = {}) {
  await ensureAccessSession(); // make sure we kicked, if needed
  
  const envConfig = await ensureEnvironmentConfig();
  const apiUrl = envConfig.getApiUrl(path);
  envConfig.debug('API fetch:', apiUrl);
  
  const fetchOptions = {
    credentials: 'include',
    ...options,
    headers: { 'Content-Type': 'application/json', ...(options.headers || {}) },
  };

  const res = await fetch(apiUrl, fetchOptions);
  
  // In local development, don't redirect on auth errors
  if (envConfig.shouldBypassAuth()) {
    return res;
  }
  
  // If something still goes sideways (e.g., Access cookie expired), re-kick.
  if (res.status === 401 || res.status === 403) {
    sessionStorage.removeItem('accessReady:v1');
    // Use the new getCurrentUserOrRedirect method
    await getCurrentUserOrRedirect();
    return new Promise(() => {});
  }
  return res;
}

// Global browser access (works in all contexts)
if (typeof window !== 'undefined') {
  window.ensureAccessSession = ensureAccessSession;
  window.apiFetch = apiFetch;
  window.getCurrentUserOrRedirect = getCurrentUserOrRedirect;
  window.apiGet = apiGet;
  window.apiPost = apiPost;
}

// ES6 module compatibility (for files that import this module)
if (typeof module !== 'undefined' && module.exports) {
  // CommonJS exports
  module.exports = { ensureAccessSession, apiFetch, getCurrentUserOrRedirect, apiGet, apiPost };
} else if (typeof window === 'undefined') {
  // ES6 module exports (only if not in browser)
  if (typeof globalThis !== 'undefined') {
    globalThis.ensureAccessSession = ensureAccessSession;
    globalThis.apiFetch = apiFetch;
    globalThis.getCurrentUserOrRedirect = getCurrentUserOrRedirect;
    globalThis.apiGet = apiGet;
    globalThis.apiPost = apiPost;
  }
}

===== END ui/src/apiClient.js =====

===== BEGIN ui/functions/_utils/verifyAccessJWT.js =====
// worker/functions/_utils/verifyAccessJWT.js
// ‚úÖ Cloudflare Zero Trust JWT verification helper

export async function verifyAccessJWT(request, env) {
  const jwt =
    request.headers.get(env.ACCESS_JWT_HEADER || 'Cf-Access-Jwt-Assertion') ||
    (request.headers.get('Cookie')?.match(/CF_Authorization=([^;]+)/)?.[1]);

  if (!jwt) {
    throw new Error('Missing Access token');
  }

  // Decode payload
  const [headerB64, payloadB64, signatureB64] = jwt.split('.');
  const payload = JSON.parse(atob(payloadB64));

  // Validate audience
  if (!payload.aud || !payload.aud.includes(env.POLICY_AUD)) {
    throw new Error('Invalid audience (AUD mismatch)');
  }

  // Fetch Cloudflare Access signing keys
  const teamDomain = env.TEAM_DOMAIN?.replace(/^https?:\/\//, '');
  const res = await fetch(`https://${teamDomain}/cdn-cgi/access/certs`);
  const { keys } = await res.json();

  // Verify signature
  const encoder = new TextEncoder();
  const data = encoder.encode(`${headerB64}.${payloadB64}`);
  const signature = Uint8Array.from(
    atob(signatureB64.replace(/-/g, '+').replace(/_/g, '/')),
    c => c.charCodeAt(0)
  );

  const key = await crypto.subtle.importKey(
    'jwk',
    keys[0],
    { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' },
    false,
    ['verify']
  );

  const verified = await crypto.subtle.verify(
    'RSASSA-PKCS1-v1_5',
    key,
    signature,
    data
  );

  if (!verified) {
    throw new Error('JWT signature invalid');
  }

  return payload; // { email, aud, exp, ... }
}

===== END ui/functions/_utils/verifyAccessJWT.js =====

===== BEGIN ui/index.html =====
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>GrassrootsMVT Volunteer Hub</title>
<style>
  :root { color-scheme: light dark; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 1rem; max-width: 880px; position: relative; }
  .auth-status { position: fixed; top: 8px; right: 8px; z-index: 100; font-size: .875rem; padding: .5rem .75rem; border-radius: 8px; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; }
  .card { border:1px solid #e5e7eb; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
  .row { display:flex; gap:1rem; flex-wrap: wrap; }
  .row > * { flex:1 1 220px; }
  label { display:block; margin:.4rem 0 .25rem; font-weight:600; }
  select, input[type=number] { width:100%; padding:.6rem; border:1px solid #cbd5e1; border-radius:8px; }
  .muted { color:#64748b; }
  .btns { display:flex; gap:.75rem; flex-wrap: wrap; margin-top:.75rem; align-items:center; }
  button { padding:.7rem 1.1rem; border-radius:10px; border:0; font-weight:700; cursor:pointer; }
  button.primary { background:#0ea5e9; color:white; }
  button.secondary { background:#e2e8f0; color:#0f172a; }
  button[disabled] { opacity:.5; cursor:not-allowed; }
  .chips { display:flex; gap:.5rem; flex-wrap: wrap; }
  a { color: #0ea5e9; }
  .quick-actions { background: #f8fafc; border: 1px solid #e2e8f0; border-radius: 12px; padding: 1rem; margin: 1rem 0; }
  .quick-actions h3 { margin: 0 0 0.75rem; font-size: 1.1rem; color: #334155; }
  .btn-contact { background: #059669; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; transition: background 0.2s; font-size: 0.95rem; }
  .btn-contact:hover { background: #047857; }
</style>
</head>

<body>
<!-- Sign in to API banner -->
<div id="api-session-banner" style="display:none; padding:12px; background:#fff3cd; color:#3d3a00; border:1px solid #ffe69c; border-radius:8px; margin:12px 0;">
  <strong>Action needed:</strong>
  Please <a data-api-login href="#" style="text-decoration:underline;">sign in to the API</a> to continue.
</div>

<!-- Authentication status indicator -->
<div id="auth-status" class="auth-status">
  <span class="online-indicator">üîÑ Checking connection...</span>
</div>

<h1>Volunteer Hub</h1>
<p class="muted">Pick your target set, then start calling or canvassing.</p>

<!-- Quick Actions Section -->
<div class="quick-actions">
  <h3>Quick Actions</h3>
  <button class="btn-contact" onclick="location.href='contact-form/index.html'">
    üìã New Contact Entry
  </button>
</div>

<div class="card">
  <div class="row">
    <div>
      <label for="county">County</label>
      <select id="county">
        <option value="">‚Äî select ‚Äî</option>
      </select>
    </div>
    <div>
      <label for="city">City (optional)</label>
      <select id="city" disabled>
        <option value="">‚Äî any ‚Äî</option>
      </select>
    </div>
    <div>
      <label for="district_type">District type</label>
      <select id="district_type" disabled>
        <option value="">‚Äî select ‚Äî</option>
        <option value="house">House</option>
        <option value="senate">Senate</option>
      </select>
    </div>
    <div>
      <label for="district">District</label>
      <select id="district" disabled>
        <option value="">‚Äî select ‚Äî</option>
      </select>
    </div>
  </div>

  <div class="row" style="margin-top:.5rem;">
    <div>
      <label>Party</label>
      <div class="chips">
        <label class="chip"><input type="checkbox" id="p_r" value="Republican"> R</label>
        <label class="chip"><input type="checkbox" id="p_d" value="Democratic"> D</label>
        <label class="chip"><input type="checkbox" id="p_u" value="Unaffiliated"> Unaff/Minor</label>
      </div>
    </div>
    <div>
      <label for="limit">Number of voters</label>
      <input id="limit" type="number" min="1" max="200" value="50" />
    </div>
  </div>

  <div class="btns">
    <button id="startCall" class="primary" disabled>Start Calls</button>
    <button id="startCanvass" class="secondary" disabled>Start Canvass</button>
    <span id="msg" class="muted"></span>
  </div>
</div>

<script>
(function(){
  const selCounty = document.getElementById('county');
  const selCity   = document.getElementById('city');
  const selType   = document.getElementById('district_type');
  const selDist   = document.getElementById('district');
  const chkR      = document.getElementById('p_r');
  const chkD      = document.getElementById('p_d');
  const chkU      = document.getElementById('p_u');
  const numLimit  = document.getElementById('limit');
  const btnCalls  = document.getElementById('startCall');
  const btnCanv   = document.getElementById('startCanvass');
  const hint      = document.getElementById('msg');

  // Load wy.json with a fallback path
  async function fetchMeta() {
    const tryPaths = ['/admin/wy.json', '/ui/admin/wy.json'];
    let lastErr = null;
    for (const p of tryPaths) {
      try {
        const r = await fetch(p, { cache: 'no-store' });
        if (r.ok) return await r.json();
        lastErr = new Error(`${p} -> HTTP ${r.status}`);
      } catch (e) { lastErr = e; }
    }
    throw lastErr || new Error('wy.json not found');
  }

  function titleCase(s) {
    return String(s||'').toLowerCase()
      .split(/\s+/).map(w => w ? w[0].toUpperCase()+w.slice(1) : w).join(' ');
  }

  // Accept camelCase or snake_case shapes
  function normalizeWy(json) {
    const counties = json.counties || json.COUNTIES || [];
    const citiesByCounty =
      json.citiesByCounty || json.cities_by_county || {};
    const senateByCounty =
      json.senateByCounty || (json.districts_by_county && json.districts_by_county.senate) || {};
    const houseByCounty  =
      json.houseByCounty  || (json.districts_by_county && json.districts_by_county.house)  || {};
    return { counties, citiesByCounty, senateByCounty, houseByCounty };
  }

  function fillSelect(sel, items, {placeholder='‚Äî select ‚Äî', anyLabel=null}={}) {
    const prev = sel.value;
    sel.innerHTML = '';
    const opt0 = document.createElement('option');
    opt0.value = '';
    opt0.textContent = anyLabel ?? placeholder;
    sel.appendChild(opt0);
    (items || []).forEach(v => {
      const o = document.createElement('option');
      o.value = v;
      o.textContent = titleCase(v);
      sel.appendChild(o);
    });
    if ([...sel.options].some(o => o.value === prev)) sel.value = prev;
  }

  function partiesFromUI() {
    const out = [];
    if (chkR && chkR.checked) out.push('R');
    if (chkD && chkD.checked) out.push('D');
    if (chkU && chkU.checked) out.push('U');
    return out;
  }

  function canProceed() {
    const county = selCounty.value || '';
    const dtype  = selType.value || '';
    const dist   = selDist.value || '';
    if (dtype && !dist) return false;
    return !!(county || (dtype && dist));
  }

  function updateButtons() {
    const ok = canProceed();
    btnCalls.disabled = !ok;
    btnCanv.disabled  = !ok;
    hint.textContent = ok ? '' : 'Select County/City and (optionally) District to continue.';
  }

  function persistFilters() {
    const county = selCounty.value ? selCounty.value.toUpperCase() : null;
    const city   = selCity.value   ? selCity.value.toUpperCase()   : null;

    const district_type = selType.value || null;
    let district = selDist.value || null;
    if (district) {
      const n = String(parseInt(district, 10));
      district = n && !isNaN(n) ? n.padStart(2, '0') : district;
    }

    const mapParty = p => p === 'R' ? 'Republican'
                      : p === 'D' ? 'Democratic'
                      : p === 'U' ? 'Unaffiliated'
                      : p;
    const parties = partiesFromUI().map(mapParty);

    const filters = {
      county,
      city,
      district_type,
      district,
      parties,
      limit: Math.max(1, Math.min(200, Number(numLimit.value || 50))),
      require_phone: true // calls default; canvass can ignore
    };
    sessionStorage.setItem('vol.filters', JSON.stringify(filters));
    return filters;
  }

  function go(path) {
    const f = persistFilters();
    const u = new URL(path, location.origin);
    if (f.county) u.searchParams.set('county', f.county);
    if (f.city)   u.searchParams.set('city', f.city);
    if (f.district_type) u.searchParams.set('district_type', f.district_type);
    if (f.district)      u.searchParams.set('district', f.district);
    f.parties?.forEach(p => u.searchParams.append('parties', p));
    if (f.limit) u.searchParams.set('limit', String(f.limit));
    location.href = u.toString();
  }

  [selCounty, selCity, selType, selDist, chkR, chkD, chkU, numLimit].forEach(el =>
    el && el.addEventListener('change', updateButtons)
  );
  document.getElementById('startCall').addEventListener('click', () => go('/call.html'));
  document.getElementById('startCanvass').addEventListener('click',  () => go('/canvass/'));

  fetchMeta().then(raw => {
    const wy = normalizeWy(raw);

    fillSelect(selCounty, wy.counties);

    selCounty.addEventListener('change', () => {
      const cty = selCounty.value || '';
      const cities = (wy.citiesByCounty[cty] || []).slice().sort();
      fillSelect(selCity, cities, { placeholder: '‚Äî any ‚Äî', anyLabel: '‚Äî any ‚Äî' });
      selCity.disabled = false;

      selType.value = '';
      selType.disabled = false;
      fillSelect(selDist, [], { placeholder: '‚Äî select ‚Äî' });
      selDist.disabled = true;
      updateButtons();
    });

    selType.addEventListener('change', () => {
      const cty = selCounty.value || '';
      const dtype = selType.value;
      let dists = [];
      if (dtype === 'house')   dists = wy.houseByCounty[cty]  || [];
      if (dtype === 'senate')  dists = wy.senateByCounty[cty] || [];
      fillSelect(selDist, dists);
      selDist.disabled = !dists.length;
      updateButtons();
    });

    selCity.addEventListener('change', updateButtons);

    updateButtons();
  }).catch(err => {
    console.error('Failed to load wy.json', err);
    hint.textContent = 'Failed to load county/city metadata.';
  });
})();
</script>

<script type="module">
// Import environment configuration
import environmentConfig from './config/environments.js';

// Environment-aware API client implementation
function ensureAccessSession() {
  // Bypass authentication in local development
  if (environmentConfig.shouldBypassAuth()) {
    environmentConfig.debug('Bypassing authentication in local development');
    sessionStorage.setItem('accessReady:v1', 'true');
    return Promise.resolve();
  }

  const ready = sessionStorage.getItem('accessReady:v1') === 'true';
  if (!ready) {
    // Direct kick to protected endpoint - no interstitial needed
    const returnTo = encodeURIComponent(location.href);
    const apiUrl = environmentConfig.getApiUrl('ping', {
      finish: environmentConfig.getApiUrl('auth/finish', { to: returnTo })
    });
    environmentConfig.debug('Redirecting to authentication:', apiUrl);
    window.location.replace(apiUrl);
    // Return a pending promise so callers don't proceed
    return new Promise(() => {});
  }
  return Promise.resolve();
}

// Centralized API fetch with credentials
async function apiFetch(path, options = {}) {
  await ensureAccessSession(); // make sure we kicked, if needed
  
  const apiUrl = environmentConfig.getApiUrl(path);
  environmentConfig.debug('API fetch:', apiUrl);
  
  const fetchOptions = {
    credentials: 'include',
    ...options,
    headers: { 'Content-Type': 'application/json', ...(options.headers || {}) },
  };

  const res = await fetch(apiUrl, fetchOptions);
  
  // In local development, don't redirect on auth errors
  if (environmentConfig.shouldBypassAuth()) {
    return res;
  }
  
  // If something still goes sideways (e.g., Access cookie expired), re-kick.
  if (res.status === 401 || res.status === 403) {
    sessionStorage.removeItem('accessReady:v1');
    // Direct kick to protected endpoint - no interstitial needed
    const returnTo = encodeURIComponent(location.href);
    const authUrl = environmentConfig.getApiUrl('ping', {
      finish: environmentConfig.getApiUrl('auth/finish', { to: returnTo })
    });
    environmentConfig.debug('Re-authenticating due to 401/403:', authUrl);
    window.location.replace(authUrl);
    return new Promise(() => {});
  }
  return res;
}

function showBanner() {
  const banner = document.getElementById('api-session-banner');
  banner.style.display = '';
  const link = banner.querySelector('[data-api-login]');
  link.addEventListener('click', (e) => {
    e.preventDefault();
    signIn(); // Use the centralized sign-in function
  });
}

// Authentication helper functions
function signIn() {
  const to = encodeURIComponent(location.href);
  const apiOrigin = environmentConfig.getApiUrl('').replace('/api', '');
  location.href = `${apiOrigin}/whoami?nav=1&to=${to}`;
}

function signOut() {
  const to = encodeURIComponent(location.origin + "/");
  const apiOrigin = environmentConfig.getApiUrl('').replace('/api', '');
  location.href = `${apiOrigin}/auth/logout?to=${to}`;
}

// Refresh user badge by calling the API
async function refreshUserBadge() {
  const indicator = document.querySelector('.online-indicator');
  if (!indicator) return;

  try {
    // In local development, always show as authenticated
    if (environmentConfig.shouldBypassAuth()) {
      const envLabel = environmentConfig.config.isLocal ? ' (Local)' : '';
      indicator.textContent = `‚úÖ Authenticated${envLabel}`;
      indicator.parentElement.style.background = '#dcfce7';
      indicator.parentElement.style.color = '#166534';
      return;
    }

    // In production, check via direct API call (no redirects)
    const apiUrl = environmentConfig.getApiUrl('whoami');
    const response = await fetch(apiUrl, { 
      credentials: 'include',
      headers: { 'Accept': 'application/json' }
    });

    if (response.ok) {
      const data = await response.json();
      if (data.ok && data.email) {
        indicator.textContent = `‚úÖ Signed in as: ${data.email}`;
        indicator.parentElement.style.background = '#dcfce7';
        indicator.parentElement.style.color = '#166534';
        
        // Remove sign-in button if present
        const signInBtn = document.querySelector('#sign-in-btn');
        if (signInBtn) signInBtn.remove();
        
        // Add sign-out button if not present
        let signOutBtn = document.querySelector('#sign-out-btn');
        if (!signOutBtn) {
          signOutBtn = document.createElement('button');
          signOutBtn.id = 'sign-out-btn';
          signOutBtn.textContent = 'Sign Out';
          signOutBtn.onclick = signOut;
          signOutBtn.style.cssText = 'margin-left: 10px; padding: 4px 8px; font-size: 12px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;';
          indicator.parentElement.appendChild(signOutBtn);
        }
        return; // Successfully authenticated
      }
    }
    
    // If we get here, not authenticated
    throw new Error('Not authenticated');
  } catch (err) {
    // Not authenticated or API error - show sign-in state
    indicator.textContent = '‚ö†Ô∏è Not signed in';
    indicator.parentElement.style.background = '#fef3c7';
    indicator.parentElement.style.color = '#92400e';
    
    // Remove sign-out button if present
    const signOutBtn = document.querySelector('#sign-out-btn');
    if (signOutBtn) signOutBtn.remove();
    
    // Add sign-in button if not present
    let signInBtn = document.querySelector('#sign-in-btn');
    if (!signInBtn) {
      signInBtn = document.createElement('button');
      signInBtn.id = 'sign-in-btn';
      signInBtn.textContent = 'Sign In';
      signInBtn.onclick = signIn;
      signInBtn.style.cssText = 'margin-left: 10px; padding: 4px 8px; font-size: 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer;';
      indicator.parentElement.appendChild(signInBtn);
    }
    
    console.log('Authentication check:', err.message || 'Not authenticated');
  }
}

// Initialize authentication on page load
document.addEventListener('DOMContentLoaded', async () => {
  console.log(`üöÄ GrassrootsMVT initializing in ${environmentConfig.config.environment} environment...`);
  environmentConfig.debug('Environment configuration:', environmentConfig.config);

  // Refresh user badge to show current authentication status
  await refreshUserBadge();

  // Note: Authentication status is now checked via refreshUserBadge()
  // No need for additional API calls that might trigger redirects
  console.log('üîê Authentication status check completed via user badge');
});
</script>

</body>
</html>
===== END ui/index.html =====

===== BEGIN ui/volunteer/index.html =====
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>Grassroots Volunteer Portal</title>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="../favicon.ico">
  
  <!-- PWA Manifest -->
  <link rel="manifest" href="../manifest.json">
  
  <!-- Theme and Meta Tags -->
  <meta name="theme-color" content="#1d4ed8">
  <meta name="description" content="GrassrootsMVT Volunteer Portal for voter outreach and engagement in Wyoming.">
  
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="GrassrootsMVT Volunteer Portal">
  <meta property="og:description" content="Join Wyoming volunteers in connecting with voters statewide.">
  <meta property="og:image" content="../assets/preview.png">
  <meta property="og:type" content="website">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            grassroots: {
              50: '#f0f9ff',
              500: '#0ea5e9',
              600: '#0284c7',
              700: '#0369a1',
            }
          }
        }
      }
    }
  </script>
</head>
<body class="bg-gradient-to-br from-blue-50 to-indigo-100 min-h-screen">
  <!-- Main Container -->
  <div class="container mx-auto px-4 py-8 max-w-2xl">
    
    <!-- Header -->
    <div class="text-center mb-8">
      <div class="inline-flex items-center justify-center w-16 h-16 bg-grassroots-500 text-white rounded-full mb-4">
        <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path>
        </svg>
      </div>
      <h1 class="text-3xl font-bold text-gray-800 mb-2">Grassroots Volunteer Portal</h1>
      <p class="text-gray-600 text-lg">Select your activity and region to begin outreach.</p>
    </div>

    <!-- Loading State -->
    <div id="loadingState" class="bg-white rounded-xl shadow-lg p-8 text-center">
      <div class="inline-flex items-center">
        <svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-grassroots-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="text-lg text-gray-600">Loading geographic data...</span>
      </div>
    </div>

    <!-- Main Card (Initially Hidden) -->
    <div id="mainCard" class="bg-white rounded-xl shadow-lg p-8 transition-all duration-300 hover:shadow-xl hidden">
      
      <!-- Form -->
      <form id="volunteerForm" class="space-y-6">
        
        <!-- Activity Selection -->
        <div class="space-y-2">
          <label for="activity" class="block text-sm font-semibold text-gray-700">
            Volunteer Activity
          </label>
          <select id="activity" name="activity" required 
                  class="w-full px-4 py-3 border-2 border-gray-200 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200">
            <option value="">Select Activity</option>
            <option value="phone">Phone Banking</option>
            <option value="canvass">Canvassing</option>
          </select>
        </div>

        <!-- Dynamic District-City Targeting -->
        <div class="bg-gray-50 rounded-lg p-6 space-y-4">
          <h3 class="text-lg font-semibold text-gray-800 mb-4">Geographic Targeting</h3>
          
          <!-- Smart Selection Mode -->
          <div class="space-y-2">
            <label for="selection-mode" class="block text-sm font-medium text-gray-700">Start By</label>
            <select id="selection-mode" name="selection-mode" disabled
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
              <option value="">Choose your starting point</option>
              <option value="district">District (recommended)</option>
              <option value="city">City/County</option>
            </select>
          </div>

          <!-- City-First Mode -->
          <div id="city-first-mode" class="hidden space-y-4">
            <div class="space-y-2">
              <label for="county-selector" class="block text-sm font-medium text-gray-700">County</label>
              <select id="county-selector" name="county" disabled
                      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <option value="">Select County</option>
              </select>
            </div>
            
            <!-- Auto-populated Districts (City Mode) -->
            <div id="auto-districts" class="hidden space-y-2">
              <div class="p-3 bg-green-50 border border-green-200 rounded-lg">
                <div class="text-sm text-green-700">
                  <strong>Districts found:</strong>
                  <div id="found-districts" class="mt-1 text-xs"></div>
                </div>
              </div>
            </div>
          </div>

          <!-- District-First Mode (existing) -->
          <div id="district-first-mode" class="hidden space-y-4">
            <!-- District Type Selection -->
            <div class="space-y-2">
              <label for="district-type" class="block text-sm font-medium text-gray-700">District Type</label>
              <select id="district-type" name="district-type" disabled
                      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <option value="">Select District Type</option>
                <option value="house">House District</option>
                <option value="senate">Senate District</option>
              </select>
            </div>

            <!-- District Number Selection -->
            <div class="space-y-2">
              <label for="district-number" class="block text-sm font-medium text-gray-700">District Number</label>
              <select id="district-number" name="district-number" disabled
                      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <option value="">Select District</option>
              </select>
            </div>

            <!-- City Selection (District Mode) -->
            <div class="space-y-2">
              <label for="city" class="block text-sm font-medium text-gray-700">
                City <span class="text-gray-400 text-xs">(automatically populated)</span>
              </label>
              <select id="city" name="city" disabled
                      class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-grassroots-500 focus:border-grassroots-500 transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <option value="">Select City</option>
              </select>
            </div>
          </div>

          <!-- Loading Indicator for Cities -->
          <div id="city-loading" class="hidden">
            <div class="flex items-center justify-center py-2">
              <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-grassroots-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
              </svg>
              <span class="text-sm text-gray-600">Loading cities...</span>
            </div>
          </div>

          <!-- City Error State -->
          <div id="city-error" class="hidden">
            <div class="p-3 bg-red-50 border border-red-200 rounded-lg">
              <div class="flex items-center justify-between">
                <span class="text-red-700 text-sm">Unable to load cities</span>
                <button type="button" id="retry-cities" class="text-red-600 hover:text-red-800 text-sm font-medium">
                  Retry
                </button>
              </div>
            </div>
          </div>
        </div>

        <!-- Start Button -->
        <div class="pt-4">
          <button type="submit" id="start-btn" disabled
                  class="w-full bg-grassroots-500 hover:bg-grassroots-600 text-white font-semibold py-4 px-6 rounded-lg transition-all duration-200 transform hover:scale-[1.02] hover:shadow-lg disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none">
            <span class="flex items-center justify-center">
              <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7l5 5m0 0l-5 5m5-5H6"></path>
              </svg>
              Start
            </span>
          </button>
        </div>

      </form>

      <!-- Help Text -->
      <div class="mt-6 p-4 bg-blue-50 rounded-lg">
        <p class="text-sm text-blue-700">
          <strong>Smart Selection:</strong> Choose to start by <em>District</em> (recommended) or <em>City/County</em>. 
          District mode shows available cities for your chosen district. City mode shows available districts for your chosen county.
          When selections are unique, fields auto-populate for a streamlined experience.
        </p>
      </div>

    </div>

    <!-- Error State -->
    <div id="errorState" class="bg-red-50 border border-red-200 rounded-xl p-6 text-center hidden">
      <div class="text-red-600 mb-2">
        <svg class="w-12 h-12 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
        </svg>
      </div>
      <h3 class="text-lg font-semibold text-red-800 mb-2">Unable to Load Data</h3>
      <p class="text-red-600 mb-4">There was an error loading geographic data from the server.</p>
      <button onclick="location.reload()" class="bg-red-600 hover:bg-red-700 text-white px-4 py-2 rounded-lg transition-colors">
        Try Again
      </button>
    </div>

    <!-- Footer -->
    <footer class="text-center mt-8 text-gray-500 text-sm">
      GrassrootsMVT ¬© 2025
    </footer>

  </div>

  <!-- JavaScript -->
  <script type="module" src="../src/api-shim.js"></script>
  <script type="module">
    // Import authentication-enabled API client
    import { 
      authenticatedFetch, 
      getAuthStatus, 
      showToast 
    } from '../src/apiClient.js';
    
    let metadata = null;
    let currentMode = null; // 'district' or 'city'

    // API Configuration with environment detection
    const API_BASE = window.location.hostname.includes('localhost') 
      ? 'http://localhost:8787' 
      : 'https://api.grassrootsmvt.org';

    // DOM Elements
    const elements = {
      activity: null,
      selectionMode: null,
      // District mode elements
      districtFirstMode: null,
      districtType: null,
      districtNumber: null,
      city: null,
      // City mode elements
      cityFirstMode: null,
      countySelector: null,
      autoDistricts: null,
      foundDistricts: null,
      // Common elements
      startBtn: null,
      cityLoading: null,
      cityError: null,
      retryCities: null
    };

    // Initialize DOM elements
    function initElements() {
      elements.activity = document.getElementById('activity');
      elements.selectionMode = document.getElementById('selection-mode');
      // District mode
      elements.districtFirstMode = document.getElementById('district-first-mode');
      elements.districtType = document.getElementById('district-type');
      elements.districtNumber = document.getElementById('district-number');
      elements.city = document.getElementById('city');
      // City mode
      elements.cityFirstMode = document.getElementById('city-first-mode');
      elements.countySelector = document.getElementById('county-selector');
      elements.autoDistricts = document.getElementById('auto-districts');
      elements.foundDistricts = document.getElementById('found-districts');
      // Common
      elements.startBtn = document.getElementById('start-btn');
      elements.cityLoading = document.getElementById('city-loading');
      elements.cityError = document.getElementById('city-error');
      elements.retryCities = document.getElementById('retry-cities');
    }

    // Check authentication status before proceeding
    async function checkAuthentication() {
      const authStatus = getAuthStatus();
      console.log('üîê Authentication Status:', authStatus);
      
      if (!authStatus.hasToken) {
        showToast('Authentication required. Please log in.', 'error', 5000);
        // Show authentication notice
        document.getElementById('loadingState').innerHTML = `
          <div class="text-center">
            <svg class="mx-auto h-12 w-12 text-red-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <h3 class="text-lg font-medium text-red-700 mb-2">Authentication Required</h3>
            <p class="text-red-600 mb-4">Please log in to access the volunteer portal.</p>
            <button onclick="window.location.reload()" class="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg transition-colors duration-200">
              Retry Authentication
            </button>
          </div>
        `;
        return false;
      }
      
      showToast(`Authenticated via ${authStatus.authType}`, 'success', 2000);
      return true;
    }

    // Fetch metadata from API using authenticated requests
    async function fetchMetadata() {
      try {
        console.log('üåê Fetching metadata with authentication');
        const response = await authenticatedFetch(`${API_BASE}/api/metadata`);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.ok) {
          throw new Error(data.message || 'API returned error status');
        }
        
        console.log('‚úÖ Metadata loaded successfully:', data);
        return data;
      } catch (error) {
        console.error('‚ùå Error fetching metadata:', error);
        if (error.message.includes('Authentication')) {
          showToast('Authentication failed. Please log in again.', 'error', 5000);
        }
        throw error;
      }
    }

    // Fetch smart metadata based on selection using authenticated requests
    async function fetchSmartMetadata(params) {
      try {
        const queryString = new URLSearchParams(params).toString();
        const url = `${API_BASE}/api/metadata?${queryString}`;
        console.log('üß† Fetching smart metadata with authentication');
        
        const response = await authenticatedFetch(url);
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        if (!data.ok) {
          throw new Error(data.message || 'API returned error status');
        }
        
        console.log('‚úÖ Smart metadata loaded:', data);
        return data;
      } catch (error) {
        console.error('‚ùå Error fetching smart metadata:', error);
        throw error;
      }
    }

    // Switch between District and City modes
    function switchSelectionMode() {
      const mode = elements.selectionMode.value;
      currentMode = mode;
      
      // Hide both modes
      elements.districtFirstMode.classList.add('hidden');
      elements.cityFirstMode.classList.add('hidden');
      
      // Reset form state
      resetAllSelections();
      
      if (mode === 'district') {
        elements.districtFirstMode.classList.remove('hidden');
        setupDistrictMode();
      } else if (mode === 'city') {
        elements.cityFirstMode.classList.remove('hidden');
        setupCityMode();
      }
      
      updateStartButton();
    }

    // Setup District Mode
    function setupDistrictMode() {
      console.log('üèõÔ∏è Setting up district mode');
      
      // Populate district types
      elements.districtType.disabled = false;
      
      // Store metadata for district population
      elements.districtNumber.dataset.houseDistricts = JSON.stringify(metadata.house_districts);
      elements.districtNumber.dataset.senateDistricts = JSON.stringify(metadata.senate_districts);
    }

    // Setup City Mode
    function setupCityMode() {
      console.log('üèôÔ∏è Setting up city mode');
      
      // Populate counties (called cities in API for consistency)
      const countySelect = elements.countySelector;
      countySelect.innerHTML = '<option value="">Select County</option>';
      
      if (metadata.cities) {
        metadata.cities.forEach(county => {
          const option = document.createElement('option');
          option.value = county;
          option.textContent = county;
          countySelect.appendChild(option);
        });
        countySelect.disabled = false;
      }
    }

    // Handle county selection in city mode
    async function handleCountySelection() {
      const county = elements.countySelector.value;
      
      if (!county) {
        elements.autoDistricts.classList.add('hidden');
        updateStartButton();
        return;
      }
      
      try {
        console.log(`üìç County selected: ${county}`);
        
        // Fetch districts for this county using enhanced API
        const smartData = await fetchSmartMetadata({ city: county });
        
        if (smartData.house_districts || smartData.senate_districts) {
          const houseDistricts = smartData.house_districts || [];
          const senateDistricts = smartData.senate_districts || [];
          
          // Show districts found
          elements.foundDistricts.innerHTML = `
            House: ${houseDistricts.length ? houseDistricts.join(', ') : 'None'} | 
            Senate: ${senateDistricts.length ? senateDistricts.join(', ') : 'None'}
          `;
          elements.autoDistricts.classList.remove('hidden');
          
          // Store the data for form submission
          elements.countySelector.dataset.autoHouse = JSON.stringify(houseDistricts);
          elements.countySelector.dataset.autoSenate = JSON.stringify(senateDistricts);
          elements.countySelector.dataset.autoPopulate = 'true';
          
        } else {
          // No districts found
          elements.autoDistricts.classList.add('hidden');
          elements.countySelector.dataset.autoPopulate = 'false';
          console.log('‚ö†Ô∏è No districts found for county');
        }
        
        updateStartButton();
        
      } catch (error) {
        console.error('‚ùå Error handling county selection:', error);
        elements.autoDistricts.classList.add('hidden');
        updateStartButton();
      }
    }

    // Update district numbers based on selected type (District Mode)
    function updateDistrictNumbers() {
      const districtType = elements.districtType.value;
      const districtNumber = elements.districtNumber;
      
      districtNumber.innerHTML = '<option value="">Select District</option>';
      
      if (districtType === 'house') {
        const houseDistricts = JSON.parse(districtNumber.dataset.houseDistricts || '[]');
        houseDistricts.forEach(district => {
          const option = document.createElement('option');
          option.value = district;
          option.textContent = `House District ${district}`;
          districtNumber.appendChild(option);
        });
        districtNumber.disabled = false;
      } else if (districtType === 'senate') {
        const senateDistricts = JSON.parse(districtNumber.dataset.senateDistricts || '[]');
        senateDistricts.forEach(district => {
          const option = document.createElement('option');
          option.value = district;
          option.textContent = `Senate District ${district}`;
          districtNumber.appendChild(option);
        });
        districtNumber.disabled = false;
      } else {
        districtNumber.disabled = true;
      }
      
      // Reset downstream elements
      resetCitySelection();
      updateStartButton();
    }

    // Fetch cities for selected district (District Mode)
    async function fetchCitiesForDistrict() {
      const districtType = elements.districtType.value;
      const districtValue = elements.districtNumber.value;
      
      if (!districtType || !districtValue) return;
      
      try {
        // Show loading state
        elements.cityLoading.classList.remove('hidden');
        elements.cityError.classList.add('hidden');
        elements.city.disabled = true;
        
        console.log(`üèôÔ∏è Fetching cities for ${districtType} district ${districtValue}`);
        
        // Use smart metadata endpoint
        const params = {};
        params[`${districtType}_district`] = districtValue;
        const smartData = await fetchSmartMetadata(params);
        
        console.log('‚úÖ Cities loaded:', smartData.cities);
        populateCityDropdown(smartData.cities, smartData.auto_populate);
        
      } catch (error) {
        console.error('‚ùå Error fetching cities:', error);
        showCityError();
      } finally {
        elements.cityLoading.classList.add('hidden');
      }
    }

    // Populate city dropdown with fetched data
    function populateCityDropdown(cities, autoPopulate) {
      const citySelect = elements.city;
      citySelect.innerHTML = '<option value="">Select City</option>';
      
      if (cities && cities.length > 0) {
        cities.forEach(city => {
          const option = document.createElement('option');
          option.value = city;
          option.textContent = city;
          citySelect.appendChild(option);
        });
        citySelect.disabled = false;
        
        // Auto-select if only one option (besides (ALL))
        if (autoPopulate && cities.length === 1) {
          citySelect.value = cities[0];
        }
      } else {
        // No cities available - hide city dropdown and enable start button
        console.log('‚ÑπÔ∏è No cities found - enabling start button immediately');
        citySelect.disabled = true;
      }
      
      updateStartButton();
    }

    // Show city loading error
    function showCityError() {
      elements.cityError.classList.remove('hidden');
      elements.city.disabled = true;
    }

    // Reset city selection
    function resetCitySelection() {
      elements.city.innerHTML = '<option value="">Select City</option>';
      elements.city.disabled = true;
      elements.cityLoading.classList.add('hidden');
      elements.cityError.classList.add('hidden');
    }

    // Reset all selections
    function resetAllSelections() {
      // District mode
      if (elements.districtType) {
        elements.districtType.value = '';
        elements.districtType.disabled = true;
      }
      if (elements.districtNumber) {
        elements.districtNumber.value = '';
        elements.districtNumber.disabled = true;
      }
      resetCitySelection();
      
      // City mode
      if (elements.countySelector) {
        elements.countySelector.value = '';
        elements.countySelector.disabled = true;
      }
      if (elements.autoDistricts) {
        elements.autoDistricts.classList.add('hidden');
      }
    }

    // Update start button state
    function updateStartButton() {
      const activity = elements.activity.value;
      let isValid = false;
      
      if (activity && currentMode) {
        if (currentMode === 'district') {
          // District mode validation
          const districtType = elements.districtType.value;
          const districtNumber = elements.districtNumber.value;
          const city = elements.city.value;
          
          isValid = districtType && districtNumber && (city || elements.city.disabled);
          
        } else if (currentMode === 'city') {
          // City mode validation
          const county = elements.countySelector.value;
          const autoPopulate = elements.countySelector.dataset.autoPopulate === 'true';
          
          isValid = county && autoPopulate;
        }
      }
      
      elements.startBtn.disabled = !isValid;
      
      if (isValid) {
        elements.startBtn.classList.remove('opacity-50', 'cursor-not-allowed');
        elements.startBtn.classList.add('hover:scale-[1.02]', 'hover:shadow-lg');
      } else {
        elements.startBtn.classList.add('opacity-50', 'cursor-not-allowed');
        elements.startBtn.classList.remove('hover:scale-[1.02]', 'hover:shadow-lg');
      }
    }

    // Handle form submission
    function handleFormSubmit(e) {
      e.preventDefault();
      
      const activity = elements.activity.value;
      
      if (!activity || !currentMode) {
        alert('Please complete all required selections.');
        return;
      }
      
      // Build query parameters based on mode
      const params = new URLSearchParams({
        activity: activity,
        state: 'WY'
      });
      
      if (currentMode === 'district') {
        // District mode submission
        const districtType = elements.districtType.value;
        const districtValue = elements.districtNumber.value;
        const cityValue = elements.city.value;
        
        if (!districtType || !districtValue) {
          alert('Please complete all district selections.');
          return;
        }
        
        params.append(`${districtType}_district`, districtValue);
        
        if (cityValue) {
          params.append('city', cityValue);
        }
        
      } else if (currentMode === 'city') {
        // City mode submission
        const county = elements.countySelector.value;
        const autoHouse = JSON.parse(elements.countySelector.dataset.autoHouse || '[]');
        const autoSenate = JSON.parse(elements.countySelector.dataset.autoSenate || '[]');
        
        if (!county) {
          alert('Please select a county.');
          return;
        }
        
        params.append('city', county);
        
        // Add auto-populated districts for reference
        if (autoHouse.length === 1) {
          params.append('house_district', autoHouse[0]);
        }
        if (autoSenate.length === 1) {
          params.append('senate_district', autoSenate[0]);
        }
      }
      
      // Determine target page
      const targetPage = `/volunteer/${activity}.html`;
      const url = `${targetPage}?${params.toString()}`;
      
      console.log('üöÄ Redirecting to:', url);
      
      // Add loading state
      elements.startBtn.innerHTML = `
        <span class="flex items-center justify-center">
          <svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          Loading...
        </span>
      `;
      elements.startBtn.disabled = true;
      
      // Navigate after brief delay
      setTimeout(() => {
        window.location.href = url;
      }, 500);
    }

    // Setup event listeners
    function setupEventListeners() {
      // Activity selection enables selection mode
      elements.activity.addEventListener('change', () => {
        const hasActivity = elements.activity.value;
        elements.selectionMode.disabled = !hasActivity;
        
        if (!hasActivity) {
          // Reset everything if no activity
          elements.selectionMode.value = '';
          currentMode = null;
          switchSelectionMode();
        }
        
        updateStartButton();
      });
      
      // Selection mode change
      elements.selectionMode.addEventListener('change', switchSelectionMode);
      
      // District mode event listeners
      elements.districtType.addEventListener('change', updateDistrictNumbers);
      elements.districtNumber.addEventListener('change', fetchCitiesForDistrict);
      elements.city.addEventListener('change', updateStartButton);
      
      // City mode event listeners
      elements.countySelector.addEventListener('change', handleCountySelection);
      
      // Retry cities button
      elements.retryCities.addEventListener('click', fetchCitiesForDistrict);
      
      // Form submission
      document.getElementById('volunteerForm').addEventListener('submit', handleFormSubmit);
      
      // Add smooth focus animations
      document.querySelectorAll('select').forEach(element => {
        element.addEventListener('focus', function() {
          if (!this.disabled) {
            this.parentElement.classList.add('scale-[1.02]');
          }
        });
        
        element.addEventListener('blur', function() {
          this.parentElement.classList.remove('scale-[1.02]');
        });
      });
    }

    // Show main card
    function showCard() {
      document.getElementById('loadingState').classList.add('hidden');
      document.getElementById('mainCard').classList.remove('hidden');
      document.getElementById('errorState').classList.add('hidden');
    }

    // Show critical error
    function showCriticalError() {
      document.getElementById('loadingState').classList.add('hidden');
      document.getElementById('mainCard').classList.add('hidden');
      document.getElementById('errorState').classList.remove('hidden');
    }

    // Initialize page with authentication check
    document.addEventListener('DOMContentLoaded', async function() {
      try {
        initElements();
        
        // Check authentication first
        const isAuthenticated = await checkAuthentication();
        if (!isAuthenticated) {
          return; // Stop initialization if not authenticated
        }
        
        metadata = await fetchMetadata();
        showCard();
        setupEventListeners();
        console.log('‚úÖ Authenticated volunteer portal initialized successfully');
      } catch (error) {
        console.error('üí• Critical error initializing page:', error);
        showCriticalError();
      }
    });
  </script>

  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('../sw.js').catch(console.error);
    }
  </script>

</body>
</html>
===== END ui/volunteer/index.html =====

===== BEGIN ui/call.html =====
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="robots" content="noindex, nofollow" />
<title>Volunteer Call</title>
<script>
  // Load environment configuration globally for non-module context
  async function loadEnvironmentConfig() {
    try {
      const module = await import('./config/environments.js');
      window.environmentConfig = module.default || module.environmentConfig;
    } catch (error) {
      console.error('Failed to load environment config:', error);
      // Fallback configuration
      window.environmentConfig = {
        shouldBypassAuth: () => location.hostname === 'localhost' || location.hostname === '127.0.0.1',
        getApiUrl: (endpoint, params = {}) => {
          const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'http://localhost:8787' : 'https://api.grassrootsmvt.org';
          
            // Handle endpoint mapping like the real environment config
            const endpointMap = {
              'ping': '/api/ping',
              'voters': '/api/voters',
              'neighborhoods': '/api/neighborhoods',
              'log': '/api/log',
              'call': '/api/call',
              'whoami': '/api/whoami'
            };          const endpointPath = endpointMap[endpoint] || (endpoint.startsWith('/') ? endpoint : `/api/${endpoint}`);
          let url = `${baseUrl}${endpointPath}`;
          
          if (Object.keys(params).length > 0) {
            const searchParams = new URLSearchParams(params);
            url += `?${searchParams.toString()}`;
          }
          return url;
        },
        debug: (message, data) => {
          const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
          if (isLocal) console.log(`[ENV-LOCAL] ${message}`, data || '');
        },
        config: {
          environment: location.hostname === 'localhost' ? 'local' : 'production',
          isLocal: location.hostname === 'localhost' || location.hostname === '127.0.0.1'
        }
      };
    }
  }
  window.envConfigReady = loadEnvironmentConfig();  // Store promise for later
</script>
<script src="/src/apiClient.js"></script>
<style>
  body { font-family: system-ui, sans-serif; margin: 1rem; max-width: 720px; }
  .card { border: 1px solid #ddd; border-radius: 12px; padding: 1rem; margin: 1rem 0; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
  label { display:block; margin:.5rem 0 .25rem; }
  input[type=text], select, textarea { width: 100%; padding:.6rem; border:1px solid #ccc; border-radius:8px; }
  button { padding:.6rem 1rem; border-radius:8px; border:0; background:#0ea5e9; color:white; font-weight:600; cursor:pointer; }
  button.secondary { background:#e2e8f0; color:#0f172a; }
  .row { display:flex; gap:.75rem; flex-wrap: wrap; }
  .row > * { flex:1 1 200px; }
  .muted { color:#64748b; }
  .error { color:#b91c1c; }
  .toolbar { display:flex; gap:.5rem; align-items:center; }
  #voterCard[hidden], #empty[hidden] { display:none; }
  h1 { display:flex; justify-content:space-between; align-items:center; margin:.25rem 0 1rem; }
</style>

<h1>
  <span>Volunteer Call</span>
  <span class="toolbar">
    <button id="getNextBtn" style="padding:8px 12px;border-radius:6px;background:#6aa9ff;color:#fff;border:none;">Get Next</button>
  </span>
</h1>

<div class="card" id="whoami">Checking login‚Ä¶</div>
<div class="card muted" id="filtersBadge" style="display:none;"></div>

<div class="card" id="voterCard" hidden>
  <div id="voterInfo" class="muted"></div>

  <h3>Call outcome</h3>

  <label for="outcome">Outcome</label>
  <select id="outcome">
    <option value="">‚Äî choose ‚Äî</option>
    <option>connected</option><option>vm</option><option>no_answer</option>
    <option>wrong_number</option><option>refused</option><option>follow_up</option>
  </select>

  <div class="row">
    <label><input type="checkbox" id="ok_callback"> OK to call back</label>
    <label><input type="checkbox" id="requested_info"> Requested info</label>
    <label><input type="checkbox" id="dnc"> Do not call</label>
  </div>

  <div class="row">
    <div>
      <label for="best_day">Best day</label>
      <select id="best_day">
        <option value="">‚Äî</option>
        <option>Mon</option><option>Tue</option><option>Wed</option>
        <option>Thu</option><option>Fri</option><option>Sat</option><option>Sun</option>
      </select>
    </div>
    <div>
      <label for="best_time_window">Best time</label>
      <select id="best_time_window">
        <option value="">‚Äî</option>
        <option>Morning</option><option>Afternoon</option><option>Evening</option>
        <option>6‚Äì8pm</option>
      </select>
    </div>
  </div>

  <div class="row">
    <label><input type="checkbox" id="optin_sms"> Opt-in SMS</label>
    <label><input type="checkbox" id="optin_email"> Opt-in Email</label>
  </div>

  <label for="email">Email address (if provided)</label>
  <input type="text" id="email" placeholder="name@example.com"/>

  <div class="row">
    <label><input type="checkbox" id="wants_volunteer"> Wants to volunteer</label>
    <label><input type="checkbox" id="share_insights_ok"> OK to share insights</label>
  </div>
  <div class="row">
    <label><input type="checkbox" id="for_term_limits"> For term limits</label>
    <label><input type="checkbox" id="issue_public_lands"> Interested: public land sales</label>
  </div>

  <label for="comments">Comments</label>
  <textarea id="comments" rows="3"></textarea>

  <div class="row" style="margin-top:.75rem;">
    <button id="saveBtn">Save & Next</button>
    <button class="secondary" id="skipBtn" type="button">Skip</button>
  </div>
  <div id="msg" class="muted" style="margin-top:.5rem;"></div>
</div>

<div class="card" id="empty" hidden>No eligible voters (or not logged in).</div>

<script>
  // Load the API shim which exposes window.apiFetch and API()
  (function(){
    // Load the API shim as an ES module so imports inside it work correctly.
    const s = document.createElement('script');
    s.type = 'module';
    s.src = '/src/api-shim.js';
    document.head.appendChild(s);
  })();

  // Debug snippet: logs token presence and tests /api/ping connectivity
  (function(){
    const dbg = document.createElement('script');
    dbg.textContent = `
      (async () => {
        const token = localStorage.getItem("access_token");
        console.log("üîê Access token present:", !!token);
        if (!token) console.warn("No access_token in localStorage ‚Äî /api/whoami will return 401");
        try {
          // Wait for apiFetch to be available
          await new Promise(resolve => {
            if (window.apiFetch) resolve();
            else setTimeout(resolve, 500);
          });
          const j = await window.apiFetch('ping'); // Remove leading slash
          console.log('üåé /api/ping result:', j);
        } catch (err) {
          console.error('Failed to reach /api/ping:', err);
        }
      })();
    `;
    document.head.appendChild(dbg);
  })();

  // Use environment-aware API URL building instead of hardcoded paths
  const API = (path) => {
    if (window.environmentConfig) {
      // Remove leading slash and /api/ if present, then let getApiUrl handle it
      const cleanPath = path.replace(/^\/?(api\/)?/, '');
      return window.environmentConfig.getApiUrl(cleanPath);
    }
    // Fallback if environment config not loaded yet
    const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    const baseUrl = isLocal ? 'http://localhost:8787' : 'https://api.grassrootsmvt.org';
    const cleanPath = path.replace(/^\/?(api\/)?/, '');
    return `${baseUrl}/api/${cleanPath}`;
  };

  const who = document.getElementById("whoami");
  const voterCard = document.getElementById("voterCard");
  const voterInfo = document.getElementById("voterInfo");
  const empty = document.getElementById("empty");
  const msg = document.getElementById("msg");
  const getNextBtn = document.getElementById('getNextBtn');
  const saveBtn = document.getElementById('saveBtn');
  const skipBtn = document.getElementById('skipBtn');
  const filtersBadge = document.getElementById('filtersBadge');

  function setMsg(text, kind="muted") {
    msg.className = kind;
    msg.textContent = text || "";
  }

  function getUrlFilters() {
    const u = new URL(location.href);
    const parties = u.searchParams.getAll('parties');
    const f = {
      county: (u.searchParams.get('county')||'').toUpperCase() || null,
      city:   (u.searchParams.get('city')||'').toUpperCase() || null,
      district_type: u.searchParams.get('district_type') || null,
      district: u.searchParams.get('district') || null,
      parties: parties.length ? parties : [],
      limit: Number(u.searchParams.get('limit')||50),
      require_phone: true
    };
    return f;
  }

  function getFilters() {
    const fromUrl = getUrlFilters();
    if (fromUrl.county || fromUrl.district_type || fromUrl.parties.length) return fromUrl;
    try { return { ...JSON.parse(sessionStorage.getItem('vol.filters')||'{}'), require_phone:true }; }
    catch { return { require_phone:true }; }
  }

  function showFiltersBadge(filters) {
    filtersBadge.style.display = 'block';
    filtersBadge.textContent = 'Filters: ' + JSON.stringify(filters);
  }

  async function jsonFetch(url, init = {}) {
    console.log('üì° jsonFetch:', url, init.method || 'GET');
    console.log('  window.apiFetch available?', !!window.apiFetch);
    
    // Wait for apiFetch to be available
    if (!window.apiFetch) {
      console.warn('‚è≥ Waiting for apiFetch to be available...');
      let attempts = 0;
      while (!window.apiFetch && attempts < 20) {
        await new Promise(r => setTimeout(r, 100));
        attempts++;
      }
      if (!window.apiFetch) {
        throw new Error('apiFetch not available after waiting');
      }
      console.log('‚úÖ apiFetch now available');
    }
    
    // For API endpoints, use the environment-aware apiFetch
    if (url.includes('/api/')) {
      // Extract the endpoint from the full URL
      const endpointMatch = url.match(/\/api\/(.+)/);
      if (endpointMatch) {
        const endpoint = endpointMatch[1];
        console.log('  ‚Üí Using apiFetch for endpoint:', endpoint);
        const response = await window.apiFetch(endpoint, init);
        console.log('  ‚Üí Response status:', response.status);
        const ct = response.headers.get("content-type") || "";
        return ct.includes("application/json") ? response.json() : response.text();
      }
    }
    
    // Fallback for non-API endpoints
    const r = await fetch(url, {
      credentials: "include",
      ...init,
      headers: { "content-type": "application/json", ...(init.headers || {}) },
    });
    if (r.status === 401) throw new Error("Unauthorized");
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    const ct = r.headers.get("content-type") || "";
    return ct.includes("application/json") ? r.json() : r.text();
  }

  async function loadWho() {
    try {
      const j = await jsonFetch(API("/whoami"));
      who.textContent = j && j.email ? ("Signed in as: " + j.email) : "Not signed in";
    } catch (e) {
      who.innerHTML = `<span class="error">Unable to reach API: ${e.message}</span>`;
    }
  }

  const SEEN_KEY = 'vol.seen_ids';
  function getSeen() {
    try { return JSON.parse(sessionStorage.getItem(SEEN_KEY) || '[]'); } catch { return []; }
  }
  function pushSeen(id) {
    if (!id) return;
    const seen = getSeen().filter(x => x !== id);
    seen.unshift(id);
    sessionStorage.setItem(SEEN_KEY, JSON.stringify(seen.slice(0, 12)));
  }

  let inFlightNext = false;

  async function nextVoter() {
    console.log('üîÑ nextVoter called');
    if (inFlightNext) return;
    inFlightNext = true;
    getNextBtn.disabled = true;
    saveBtn.disabled = true;
    setMsg("Loading next voter‚Ä¶");

    try {
      const filters = getFilters();
      const exclude_ids = getSeen();
      console.log('üìã Filters:', filters, 'Excluding:', exclude_ids);
      const v = await jsonFetch(API('/call'), {
        method: 'POST',
        body: JSON.stringify({ filters, exclude_ids })
      });

      console.log('üì® Received voter data:', v);
      
      if (!v || v.empty || !v.voter_id) {
        console.warn('‚ö†Ô∏è No voter data:', {hasData: !!v, isEmpty: v?.empty, hasVoterId: !!v?.voter_id});
        voterCard.hidden = true; empty.hidden = false; setMsg("");
        return;
      }

      // show
      empty.hidden = true; voterCard.hidden = false;
      voterCard.dataset.voter = v.voter_id;
      const name = [v.first_name, v.last_name].filter(Boolean).join(" ");
      const party = v.political_party ? (' ‚Ä¢ Party: ' + v.political_party) : '';
      const phone = v.phone_1 ? ('Phone: ' + v.phone_1) : 'Phone: ‚Äî';
      voterInfo.innerHTML =
        `<strong>${name || "‚Äî"}</strong><br/>${(v.city||'')} ${(v.county||'')}${party}<br/>${phone}`;

      // remember to avoid immediate repeats
      pushSeen(v.voter_id);                       // NEW
      setMsg("");
    } catch (e) {
      console.error('‚ùå nextVoter error:', e);
      voterCard.hidden = true; empty.hidden = false;
      setMsg(`Error: ${e.message}`, "error");
    } finally {
      inFlightNext = false;
      getNextBtn.disabled = false;
      saveBtn.disabled = false;
    }
  }

  getNextBtn.addEventListener("click", nextVoter);
  saveBtn.addEventListener("click", saveAndNext);

  async function saveAndNext() {
    const payload = {
      voter_id: voterCard.dataset.voter || "",
      outcome: document.getElementById("outcome").value,
      ok_callback: +document.getElementById("ok_callback").checked,
      requested_info: +document.getElementById("requested_info").checked,
      dnc: +document.getElementById("dnc").checked,
      best_day: document.getElementById("best_day").value || null,
      best_time_window: document.getElementById("best_time_window").value || null,
      optin_sms: +document.getElementById("optin_sms").checked,
      optin_email: +document.getElementById("optin_email").checked,
      email: document.getElementById("email").value || null,
      wants_volunteer: +document.getElementById("wants_volunteer").checked,
      share_insights_ok: +document.getElementById("share_insights_ok").checked,
      for_term_limits: +document.getElementById("for_term_limits").checked,
      issue_public_lands: +document.getElementById("issue_public_lands").checked,
      comments: document.getElementById("comments").value || null
    };
    if (!payload.voter_id) { alert("No voter selected."); return; }
    if (!payload.outcome) { alert("Choose an outcome."); return; }

    try {
      setMsg("Saving...");
  await jsonFetch(API("/complete"), { method: "POST", body: JSON.stringify(payload) });
      // reset a few fields
      document.getElementById("outcome").value = "";
      document.getElementById("best_day").value = "";
      document.getElementById("best_time_window").value = "";
      document.getElementById("email").value = "";
      document.getElementById("comments").value = "";
      ["ok_callback","requested_info","dnc","optin_sms","optin_email",
       "wants_volunteer","share_insights_ok","for_term_limits","issue_public_lands"]
       .forEach(id => document.getElementById(id).checked = false);
      setMsg("Saved.");
      // remember and fetch next
      const vid = voterCard.dataset.voter;
      if (vid) pushSeen(vid);
      nextVoter();
    } catch (e) {
      setMsg(`Save failed: ${e.message}`, "error");
    }
  }
  // make Skip also record the current id so we don‚Äôt bounce back to it
  document.getElementById("skipBtn").addEventListener("click", () => {
    const vid = voterCard.dataset.voter;
    if (vid) pushSeen(vid);
    nextVoter();
  });

  // Keyboard shortcut: N = Get Next
  window.addEventListener("keydown", (e) => {
    if (e.key.toLowerCase() === "n" && !e.metaKey && !e.ctrlKey && !e.altKey) {
      e.preventDefault(); nextVoter();
    }
  });

  const filters = getFilters();
  showFiltersBadge(filters);
  (async () => {
    if (window.envConfigReady) await window.envConfigReady;  // Wait for environment
    console.log("‚úÖ Ready, loading data...");
    await loadWho();     // don‚Äôt block if this fails; loadWho() already swallows errors
    await nextVoter();   // show a voter immediately
  })();
</script>

===== END ui/call.html =====

===== BEGIN ui/canvass/index.html =====
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Canvass</title>
<script>
  // Load environment configuration globally for non-module context
  async function loadEnvironmentConfig() {
    try {
      const module = await import('../config/environments.js');
      window.environmentConfig = module.default || module.environmentConfig;
    } catch (error) {
      console.error('Failed to load environment config:', error);
      // Fallback configuration
      window.environmentConfig = {
        shouldBypassAuth: () => location.hostname === 'localhost' || location.hostname === '127.0.0.1',
        getApiUrl: (endpoint, params = {}) => {
          const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
          const baseUrl = isLocal ? 'http://localhost:8787' : 'https://api.grassrootsmvt.org';
          
          // Handle endpoint mapping like the real environment config
          const endpointMap = {
            'ping': '/api/ping',
            'voters': '/api/voters',
            'neighborhoods': '/api/neighborhoods',
            'log': '/api/log',
            'call': '/api/call',
            'contact/status': '/api/contact/status',
            'whoami': '/api/whoami'
          };
          
          const endpointPath = endpointMap[endpoint] || (endpoint.startsWith('/') ? endpoint : `/api/${endpoint}`);
          let url = `${baseUrl}${endpointPath}`;
          
          if (Object.keys(params).length > 0) {
            const searchParams = new URLSearchParams(params);
            url += `?${searchParams.toString()}`;
          }
          return url;
        },
        debug: (message, data) => {
          const isLocal = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
          if (isLocal) console.log(`[ENV-LOCAL] ${message}`, data || '');
        },
        config: {
          environment: location.hostname === 'localhost' ? 'local' : 'production',
          isLocal: location.hostname === 'localhost' || location.hostname === '127.0.0.1'
        }
      };
    }
  }
  loadEnvironmentConfig();
</script>
<script src="/src/apiClient.js"></script>
<script src="../shared/streetAutocomplete.js"></script>
<style>
  :root { --gap: 10px; }
  body { font-family: system-ui, sans-serif; margin: 12px; position: relative; }
  .auth-status { position: fixed; top: 8px; right: 8px; z-index: 100; font-size: 0.875rem; padding: 0.5rem 0.75rem; border-radius: 8px; background: #f1f5f9; color: #475569; border: 1px solid #e2e8f0; }
  .card { border:1px solid #e5e7eb; border-radius:12px; padding:12px; margin:12px 0; box-shadow:0 1px 2px rgba(0,0,0,.04); }
  h1 { font-size: 1.4rem; margin: 4px 0 12px; }
  .row { display:flex; gap:var(--gap); flex-wrap:wrap; align-items:center; }
  .row > * { flex:1 1 140px; }
  label { font-size:.9rem; color:#334155; }
  input[type=number], input[type=text], select, button {
    width:100%; font-size:1rem; padding:.7rem .75rem; border:1px solid #cbd5e1; border-radius:10px;
  }
  input:disabled {
    background-color: #f8fafc;
    color: #64748b;
    cursor: not-allowed;
    border-color: #e2e8f0;
  }
  button.primary { background:#2563eb; color:white; border:0; font-weight:600; }
  .muted { color:#64748b }
  .autocomplete-container { position: relative; }
  .autocomplete-suggestions { 
    position: absolute; 
    top: 100%; 
    left: 0; 
    right: 0; 
    background: white; 
    border: 2px solid #2563eb; 
    border-top: none; 
    border-radius: 0 0 10px 10px; 
    max-height: 200px; 
    overflow-y: auto; 
    z-index: 9999; 
    display: none; 
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }
  .autocomplete-suggestion { 
    padding: 12px 16px; 
    cursor: pointer; 
    border-bottom: 1px solid #f1f5f9; 
    font-weight: 500;
    background: white;
  }
  .autocomplete-suggestion:hover { background: #f8fafc; border-color: #e2e8f0; }
  .autocomplete-suggestion:last-child { border-bottom: none; }
  .person-name { font-weight:700; font-size:1.1rem; color:#1e293b; margin-bottom:4px; }
  .addr { font-weight:500; color:#475569; font-size:.95rem; }
  .location-details { font-size:.85rem; color:#64748b; margin-top:2px; }
  .chip { display:inline-block; border:1px solid #cbd5e1; border-radius:999px; padding:.15rem .5rem; font-size:.8rem; margin-left:6px; }
  button[disabled] { opacity:.45; cursor:not-allowed; }
  .muted-chip { border:1px solid #e5e7eb; color:#64748b; }
  .list > div { padding:10px 0; border-bottom:1px solid #f1f5f9; }
  .list > div:last-child { border-bottom:0; }
  .toolbar { display:flex; gap:8px; }
</style>
</head>

<body>
<!-- Authentication status indicator -->
<div id="auth-status" class="auth-status">
  <span class="online-indicator">üîÑ Checking connection...</span>
</div>

<h1>Canvass</h1>

<div class="card">
  <div class="muted" id="filtersBadge">Loading filters‚Ä¶</div>
</div>

<div class="card">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
    <h3 style="margin: 0; color: #1e293b;">Address Lookup</h3>
    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.9rem; color: #475569;">
      <input type="checkbox" id="instructionsToggle" style="margin: 0;" checked>
      Show step-by-step instructions
    </label>
  </div>
  
  <div id="instructionsPanel" style="background: #f0f9ff; border: 1px solid #0ea5e9; border-radius: 8px; padding: 16px; margin-bottom: 16px;">
    <div id="instructionText" style="font-weight: 500; color: #0369a1;">
      üëã Click on the Street field below to start
    </div>
  </div>

  <div class="card">
    <div class="row">
      <div class="autocomplete-container">
        <label for="house">House #</label>
        <input id="house" type="text" placeholder="Select street first" inputmode="numeric" autocomplete="off" disabled />
        <div id="houseSuggestions" class="autocomplete-suggestions"></div>
      </div>
      <div class="autocomplete-container">
        <label for="street">Street</label>
        <input id="street" type="text" placeholder="e.g. RAVEN ST" autocomplete="off" />
        <div id="streetSuggestions" class="autocomplete-suggestions"></div>
      </div>
    </div>
  <div class="row" style="margin-top:8px;">
    <div>
      <label for="range">Number range (¬±)</label>
      <select id="range">
        <option>10</option><option selected>20</option><option>30</option><option>50</option>
      </select>
    </div>
    <div>
      <label for="limit">Max addresses</label>
      <select id="limit">
        <option>10</option><option selected>20</option><option>30</option><option>50</option>
      </select>
    </div>
  </div>
  <div class="row" style="margin-top:10px;">
    <button class="primary" id="btnFind">Find nearby</button>
  </div>
  <div id="msg" class="muted" style="margin-top:8px;"></div>
</div>

<div class="card">
  <div class="list" id="results"></div>
</div>

<div id="toast" style="position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#111827;color:white;padding:8px 12px;border-radius:8px;display:none;box-shadow:0 4px 12px rgba(0,0,0,.2);">Opening call...</div>

<script>
  // Load API shim (exposes window.apiFetch and API())
  (function(){
    const s = document.createElement('script');
    s.type = 'module';
    s.src = '/src/api-shim.js';
    document.head.appendChild(s);
  })();

  // Debug snippet: logs token presence and tests /api/ping connectivity
  (function(){
    const dbg = document.createElement('script');
    dbg.textContent = `
      (async () => {
        const token = localStorage.getItem("access_token");
        console.log("üîê Access token present:", !!token);
        if (!token) console.warn("No access_token in localStorage ‚Äî /api/whoami will return 401");
        
        // Note: Removed automatic apiFetch call to prevent redirect loops
        // API connectivity will be tested when user actually performs actions
        console.log('üö™ Canvass page initialized - API calls will happen on user interaction');
      })();
    `;
    document.head.appendChild(dbg);
  })();
  const API = (p) => '/api' + p;

  function fromQS() {
    const u = new URL(location.href);
    const parties = u.searchParams.getAll('parties');
    const f = {
      county: (u.searchParams.get('county')||'').toUpperCase() || null,
      city:   (u.searchParams.get('city')||'').toUpperCase() || null,
      district_type: u.searchParams.get('district_type') || null,
      district: u.searchParams.get('district') || null,
      parties: parties.length ? parties : [],
    };
    return f;
  }

  function showFiltersBadge(f) {
    const badge = document.getElementById('filtersBadge');
    badge.textContent = 'Filters: ' + JSON.stringify(f);
  }

  async function jsonFetch(url, init={}) {
    console.log('üîó jsonFetch called with:', url, 'apiFetch available:', !!window.apiFetch);
    
    if (url.startsWith('/api') && window.apiFetch) {
      console.log('üì± Using apiFetch with path:', url.replace('/api/',''));
      // apiFetch expects just the path part without /api prefix
      const response = await window.apiFetch(url.replace('/api/',''), init);
      if (!response.ok) throw new Error('HTTP '+response.status);
      const ct = response.headers.get('content-type')||'';
      return ct.includes('application/json') ? response.json() : response.text();
    }
    
    // Fallback: construct full URL to worker
    let fullUrl = url;
    if (url.startsWith('/api')) {
      fullUrl = 'http://localhost:8787' + url;
      console.log('üîÑ Fallback to worker URL:', fullUrl);
    }
    
    const r = await fetch(fullUrl, {
      credentials: 'include',
      ...init,
      headers: { 'content-type': 'application/json', ...(init.headers||{}) }
    });
    if (!r.ok) throw new Error('HTTP '+r.status);
    const ct = r.headers.get('content-type')||'';
    return ct.includes('application/json') ? r.json() : r.text();
  }

  function setMsg(t) { document.getElementById('msg').textContent = t || ''; }

  async function renderList(rows) {
    console.log('üé® renderList called with:', rows);
    const el = document.getElementById('results');
    console.log('üé® Results element:', el);
    
    el.innerHTML = '';
    if (!rows || !rows.length) { 
      console.log('üé® No rows to display');
      el.innerHTML = '<div class="muted">No nearby addresses.</div>'; 
      return; 
    }
    
    console.log('üé® Rendering', rows.length, 'rows');
    
    // Fetch contact status for all voters
    let contactStatus = {};
    try {
      const voter_ids = rows.map(r => r.voter_id).join(',');
      console.log('üìû Fetching contact status for voter IDs:', voter_ids);
      
      const response = await jsonFetch(`/api/contact/status?voter_ids=${voter_ids}`);
      if (response.ok) {
        contactStatus = response.contacts || {};
        console.log('üìû Contact status loaded:', contactStatus);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Failed to load contact status:', error);
    }
    
    for (const r of rows) {
      const div = document.createElement('div');
      div.className = 'voter-card'; // Add a class to identify voter cards
      
      // Get contact info for this voter
      const contact = contactStatus[r.voter_id];
      let contactInfo = '';
      
      if (contact) {
        const contactDate = new Date(contact.created_at).toLocaleDateString();
        const volunteer = contact.volunteer_email || 'Unknown';
        const shortVolunteer = volunteer.split('@')[0]; // Show just the username part
        
        // Style based on contact outcome
        let statusColor = '#6b7280'; // gray
        let statusIcon = 'üìã';
        
        switch (contact.outcome?.toLowerCase()) {
          case 'connected':
          case 'contacted':
          case 'brief':
            statusColor = '#059669'; // green
            statusIcon = '‚úÖ';
            break;
          case 'no_answer':
          case 'not home':
            statusColor = '#d97706'; // orange
            statusIcon = 'üö™';
            break;
          case 'refused':
          case 'dnc':
          case 'do not contact':
            statusColor = '#dc2626'; // red
            statusIcon = 'üö´';
            break;
          case 'moved':
          case 'wrong_address':
            statusColor = '#7c3aed'; // purple
            statusIcon = 'üì¶';
            break;
        }
        
        contactInfo = `
          <div class="contact-status" style="margin-top:4px; padding:4px 8px; background:#f8fafc; border-left:3px solid ${statusColor}; font-size:0.85rem;">
            ${statusIcon} <strong>${contact.outcome}</strong> by ${shortVolunteer} on ${contactDate}
            ${contact.method ? ` (${contact.method})` : ''}
          </div>
        `;
      }
      
      div.innerHTML = `
        <div class="person-name">${r.name || 'Name Unknown'} <span style="font-size:0.8rem;font-weight:400;color:#64748b;">(ID: ${r.voter_id})</span></div>
        <div class="addr">${r.address}</div>
        <div class="location-details">${r.city} ${r.zip}
          <span class="chip">${r.party||'Unknown Party'}</span>
          ${r.phone_e164
            ? `<span class="chip">${r.phone_e164}${r.phone_confidence ? ' ('+r.phone_confidence+')' : ''}</span>`
            : `<span class="chip muted-chip">no phone</span>`}
        </div>
        ${contactInfo}
        <div class="toolbar" style="margin-top:8px;">
          <button data-id="${r.voter_id}" data-a="contacted" style="background: #059669; color: white; font-weight: 500;">üìã Contact</button>
          <button data-id="${r.voter_id}" data-a="no_answer">üö™ Not Home</button>
          <button data-id="${r.voter_id}" data-a="note">üìù Note</button>
    <button data-id="${r.voter_id}" data-a="call"
      class="primary"
      ${r.phone_e164 ? '' : 'disabled title="No phone on file" aria-disabled="true"'}
    >Call</button>
        </div>
      `;
      el.appendChild(div);
    }
    el.querySelectorAll('button[data-a]').forEach(btn => {
      btn.addEventListener('click', async () => {
        const voter_id = btn.getAttribute('data-id');
        let outcome = btn.getAttribute('data-a');
        
        if (outcome === 'call') {
          // Prefill call UI and show toast then navigate there
          try {
            const pre = { voter_id, prefill: true };
            sessionStorage.setItem('vol.call_prefill', JSON.stringify(pre));
            const toast = document.getElementById('toast');
            toast.style.display = 'block';
            setTimeout(() => { toast.style.display = 'none'; location.href = '/call.html?voter_id=' + encodeURIComponent(voter_id); }, 700);
          } catch (e) {
            alert('Unable to open call UI: ' + e.message);
          }
          return;
        }
        
        if (outcome === 'contacted') {
          // Navigate to dedicated contact page with voter data
          let voterCard = btn.closest('.voter-card'); // Use the specific class
          console.log('üîç Debug: voterCard found:', !!voterCard);
          console.log('üîç Debug: button element:', btn);
          console.log('üîç Debug: button parent:', btn.parentElement);
          
          if (!voterCard) {
            console.error('üö® Contact button error: Voter card not found');
            console.log('üîç Debug: Trying alternative selector...');
            
            // Fallback: try to find the voter card by traversing up
            let testCard = btn.parentElement;
            while (testCard && !testCard.querySelector('.person-name')) {
              testCard = testCard.parentElement;
              if (testCard === document.body) break; // Safety check
            }
            
            if (testCard && testCard.querySelector('.person-name')) {
              console.log('üîç Debug: Found voter card via fallback method');
              voterCard = testCard; // Assign to the voterCard variable
            } else {
              alert('Error: Could not find voter card. Please try again.');
              return;
            }
          }
          
          const voterNameElement = voterCard.querySelector('.person-name');
          const voterAddressElement = voterCard.querySelector('.addr');
          const locationDetailsElement = voterCard.querySelector('.location-details');
          
          console.log('üîç Debug elements found:', {
            voterName: !!voterNameElement,
            voterAddress: !!voterAddressElement, 
            locationDetails: !!locationDetailsElement
          });
          
          if (!voterNameElement || !voterAddressElement || !locationDetailsElement) {
            console.error('üö® Contact button error: Required voter elements not found');
            console.log('üîç Debug HTML structure:', voterCard?.innerHTML || 'voterCard is null');
            alert('Error: Could not find voter information. Please try again.');
            return;
          }
          
          const voterName = voterNameElement.textContent.split(' (ID:')[0];
          const voterAddress = voterAddressElement.textContent;
          const locationDetails = locationDetailsElement.textContent;
          
          // Parse city, zip, and party from location details
          const parts = locationDetails.split('‚Ä¢').map(p => p.trim());
          const cityZip = parts[0] || '';
          const [city, zip] = cityZip.split(' ').filter(p => p);
          const party = parts.find(p => !p.includes('phone') && !cityZip.includes(p)) || '';
          const phone = parts.find(p => p.includes('+1') || p.includes('phone')) || '';
          
          const contactUrl = `/contact?${new URLSearchParams({
            voter_id: voter_id,
            name: voterName,
            address: voterAddress,
            city: city || '',
            zip: zip || '',
            party: party.replace(/[^\w\s]/g, '').trim(),
            phone: phone.replace('no phone', '')
          }).toString()}`;
          
          window.location.href = contactUrl;
          return;
        }
        
        if (outcome === 'note') {
          const t = prompt('Note for this address / voter?');
          if (!t) return;
          outcome = 'note';
          comments = t;
        }
        
        // Handle simple outcomes (no_answer, etc.)
        let comments = null;
        try {
          await jsonFetch(API('/complete'), { method:'POST', body: JSON.stringify({ voter_id, outcome, comments }) });
          btn.closest('div').querySelectorAll('button').forEach(b => b.disabled = true);
        } catch (e) {
          alert('Save failed: '+e.message);
        }
      });
    });
  }

  async function findNearby() {
    const house = Number(document.getElementById('house').value || 0);
    const street = (document.getElementById('street').value || '').trim().toUpperCase();
    const range  = Number(document.getElementById('range').value);
    const limit  = Number(document.getElementById('limit').value);
    
    console.log('üîç findNearby called with:', { house, street, range, limit });
    
    if (!house || !street) {
      setMsg('Enter a house number and street.'); return;
    }
    setMsg('Searching‚Ä¶');
    const filters = fromQS();
    
    console.log('üîç Making API call with filters:', filters);
    console.log('üîç API URL will be:', API('/canvass/nearby'));
    
    try {
      const requestBody = { filters, house, street, range, limit };
      console.log('üîç Request body:', requestBody);
      
      const j = await jsonFetch(API('/canvass/nearby'), {
        method: 'POST',
        body: JSON.stringify(requestBody)
      });
      
      console.log('üîç API response:', j);
      console.log('üîç Response rows:', j.rows);
      
      await renderList(j.rows || []);
      setMsg(`Found ${j.rows?.length||0} nearby addresses.`);
    } catch (e) {
      console.error('üîç Error in findNearby:', e);
      setMsg('Error: '+e.message);
    }
  }

  // Street autocomplete functionality
  let streetCache = null;
  async function loadStreetNames() {
    if (streetCache) return streetCache;
    try {
      // Get a sample of addresses to build street list
      const filters = fromQS();
      console.log('üîç Loading streets with filters:', filters);
      console.log('üåê Current URL:', location.href);
      
      const response = await jsonFetch(API('/canvass/nearby'), {
        method: 'POST', 
        body: JSON.stringify({ filters, limit: 500 })
      });
      
      console.log('üì° API Response:', response);
      
      const streets = [...new Set((response.rows || []).map(r => {
        // Extract street name from full address (remove house number)
        return r.address.replace(/^\d+\s+/, '').toUpperCase();
      }))].sort();
      streetCache = streets;
      console.log(`‚úÖ Loaded ${streets.length} street names for autocomplete:`, streets);
      return streets;
    } catch (e) {
      console.error('‚ùå Failed to load street names:', e);
      return [];
    }
  }

  // Enable house number field
  function enableHouseField() {
    const houseInput = document.getElementById('house');
    houseInput.disabled = false;
    houseInput.placeholder = "e.g. 5201";
    houseInput.style.backgroundColor = "";
    houseInput.style.cursor = "";
  }

  // Disable house number field  
  function disableHouseField() {
    const houseInput = document.getElementById('house');
    const houseSuggestions = document.getElementById('houseSuggestions');
    
    houseInput.disabled = true;
    houseInput.value = "";
    houseInput.placeholder = "Select street first";
    houseSuggestions.style.display = 'none';
  }

  // Function to populate house numbers based on selected street
  async function populateHouseNumbers(streetName) {
    const houseInput = document.getElementById('house');
    const houseSuggestions = document.getElementById('houseSuggestions');
    
    console.log('üè† Loading house numbers for street:', streetName);
    
    try {
      const filters = fromQS();
      
      // API call to get addresses on this specific street
      const response = await fetch('http://localhost:8787/api/canvass/nearby', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ filters, street: streetName, limit: 100 })
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const data = await response.json();
      console.log('üì° House numbers API response:', data);
      
      if (data.rows && data.rows.length > 0) {
        // Extract house numbers from addresses
        const houseNumbers = [...new Set(data.rows.map(r => {
          const match = r.address.match(/^(\d+)/);
          return match ? match[1] : null;
        }).filter(Boolean))].sort((a, b) => parseInt(a) - parseInt(b));
        
        console.log('üè† Available house numbers:', houseNumbers);
        
        // Set up house number autocomplete
        setupHouseAutocomplete(houseNumbers);
      }
    } catch (error) {
      console.error('‚ùå Failed to load house numbers:', error);
    }
  }

  // Function to set up house number autocomplete
  function setupHouseAutocomplete(houseNumbers) {
    const houseInput = document.getElementById('house');
    const houseSuggestions = document.getElementById('houseSuggestions');
    
    console.log('üè† Setting up house autocomplete with numbers:', houseNumbers);
    
    // Remove any existing event listeners (prevent duplicates)
    const newHouseInput = houseInput.cloneNode(true);
    houseInput.parentNode.replaceChild(newHouseInput, houseInput);
    
    // Show house numbers on focus (only if enabled)
    newHouseInput.addEventListener('focus', function() {
      if (!this.disabled && houseNumbers && houseNumbers.length > 0) {
        houseSuggestions.innerHTML = houseNumbers.slice(0, 15).map(num => 
          `<div class="autocomplete-suggestion" data-house="${num}">${num}</div>`
        ).join('');
        houseSuggestions.style.display = 'block';
        houseSuggestions.style.backgroundColor = '#fef3c7'; // Light yellow highlight
        console.log('‚úÖ House numbers dropdown shown');
      }
    });
    
    // Filter house numbers as user types (only if enabled)
    newHouseInput.addEventListener('input', function() {
      if (this.disabled) return;
      
      const value = this.value;
      if (houseNumbers && houseNumbers.length > 0) {
        if (value.length === 0) {
          // Show all house numbers
          houseSuggestions.innerHTML = houseNumbers.slice(0, 15).map(num => 
            `<div class="autocomplete-suggestion" data-house="${num}">${num}</div>`
          ).join('');
          houseSuggestions.style.display = 'block';
        } else {
          // Filter house numbers
          const matches = houseNumbers.filter(num => num.startsWith(value)).slice(0, 15);
          if (matches.length > 0) {
            houseSuggestions.innerHTML = matches.map(num => 
              `<div class="autocomplete-suggestion" data-house="${num}">${num}</div>`
            ).join('');
            houseSuggestions.style.display = 'block';
          } else {
            houseSuggestions.style.display = 'none';
          }
        }
      }
    });
    
    // Handle house number clicks
    houseSuggestions.addEventListener('click', function(e) {
      if (e.target.classList.contains('autocomplete-suggestion')) {
        console.log('üñ±Ô∏è Clicked house number:', e.target.dataset.house);
        if (e.target.dataset.house) {
          newHouseInput.value = e.target.dataset.house;
          houseSuggestions.style.display = 'none';
          
          // Update instructions when house is selected
          updateInstruction('houseSelected');
          
          newHouseInput.focus();
        }
      }
    });
    
    // Hide house suggestions when clicking outside
    document.addEventListener('click', function(e) {
      if (!newHouseInput.contains(e.target) && !houseSuggestions.contains(e.target)) {
        houseSuggestions.style.display = 'none';
      }
    });
    
    // Prevent interaction when disabled
    newHouseInput.addEventListener('click', function(e) {
      if (this.disabled) {
        e.preventDefault();
        console.log('üö´ House field is disabled - select street first');
      }
    });
  }

  document.getElementById('btnFind').addEventListener('click', findNearby);
  
  // QoL: Enter on street field triggers search
  const streetEl = document.getElementById('street');
  document.getElementById('street').addEventListener('keydown', e => {
    if (e.key === 'Enter') { e.preventDefault(); findNearby(); }
  });
  // Auto-uppercase input to reduce mismatches
  streetEl.addEventListener('input', () => {
    const pos = streetEl.selectionStart;
    streetEl.value = (streetEl.value || '').toUpperCase();
    streetEl.selectionStart = streetEl.selectionEnd = pos;
  });

  // Initialize reusable street autocomplete component
  const streetAutocomplete = new StreetAutocomplete({
    streetInputId: 'street',
    suggestionsId: 'streetSuggestions',
    getCounty: () => fromQS().county,
    getCity: () => fromQS().city,
    onStreetSelected: (streetName) => {
      // Enable house number field
      enableHouseField();
      
      // Update instructions when street is selected
      updateInstruction('streetSelected');
      
      // Load house numbers for this street
      setTimeout(() => {
        populateHouseNumbers(streetName);
      }, 100);
    },
    onHouseFieldChange: (enabled) => {
      if (enabled) {
        enableHouseField();
      } else {
        disableHouseField();
      }
    }
  });
  
  // Instructions system
  const instructionsToggle = document.getElementById('instructionsToggle');
  const instructionsPanel = document.getElementById('instructionsPanel');
  const instructionText = document.getElementById('instructionText');
  
  console.log('üéõÔ∏è Instructions elements found:', {
    toggle: !!instructionsToggle,
    panel: !!instructionsPanel, 
    text: !!instructionText
  });
  
  // Instructions state management
  let currentStep = 'street';
  const instructions = {
    street: 'üëã Click on the Street field below to start',
    streetFocused: 'üìù Type or select a street name from the blue dropdown',
    streetSelected: 'üè† Great! Now select a house number from the yellow dropdown above',
    houseSelected: 'üîç Perfect! Click "Find nearby" to search for voters',
    searching: '‚è≥ Searching for nearby voters...',
    results: '‚úÖ Found results! Review the voters below and take action',
    noResults: '‚ùå No voters found. Try adjusting the address or range'
  };
  
  function updateInstruction(step) {
    if (!instructionsToggle.checked) return;
    currentStep = step;
    instructionText.textContent = instructions[step] || instructions.street;
    console.log('üìã Instruction updated to:', step, '‚Üí', instructions[step]);
  }
  
  // Toggle instructions panel
  instructionsToggle.addEventListener('change', () => {
    console.log('üéõÔ∏è Instructions toggle changed to:', instructionsToggle.checked);
    if (instructionsToggle.checked) {
      instructionsPanel.style.display = 'block';
      updateInstruction(currentStep);
      console.log('‚úÖ Instructions panel shown');
    } else {
      instructionsPanel.style.display = 'none';
      console.log('‚ùå Instructions panel hidden');
    }
  });
  
  // Initialize with instructions enabled
  updateInstruction('street');
  
  // Add instruction event listeners to existing elements
  const streetInput = document.getElementById('street');
  const houseInput = document.getElementById('house');
  const btnFind = document.getElementById('btnFind');
  
  // Street field events
  streetInput.addEventListener('focus', () => {
    // Only update to streetFocused if we're at the initial street step
    // Don't revert if user has already selected a street
    if (currentStep === 'street' || (currentStep === 'streetFocused' && !streetInput.value.trim())) {
      updateInstruction('streetFocused');
    }
  });
  
  // We'll handle street selection in the dropdown click handler above
  // Only update instructions for manual typing if it's a reasonable length
  streetInput.addEventListener('input', () => {
    const value = streetInput.value.trim();
    if (value.length > 3) {
      // Only update if they've typed a substantial street name
      // This helps differentiate from dropdown selections
      setTimeout(() => {
        if (streetInput.value.trim() === value && value.length > 3) {
          updateInstruction('streetSelected');
        }
      }, 500); // Small delay to see if they're still typing
    }
  });
  
  // House field events  
  houseInput.addEventListener('focus', () => {
    if (!houseInput.disabled) {
      // Don't change instruction on focus, keep current state
    }
  });
  
  // We'll handle house selection in the dropdown click handler above
  // Only update for manual typing
  houseInput.addEventListener('input', () => {
    const value = houseInput.value.trim();
    if (value.length > 0) {
      setTimeout(() => {
        if (houseInput.value.trim() === value && value.length > 0) {
          updateInstruction('houseSelected');
        }
      }, 300);
    }
  });
  
  // Find button click
  btnFind.addEventListener('click', () => {
    updateInstruction('searching');
    // Results will be updated by monitoring the results div
  });
  
  // Monitor results div for changes
  const resultsDiv = document.getElementById('results');
  const observer = new MutationObserver(() => {
    if (instructionsToggle.checked) {
      const hasResults = resultsDiv.children.length > 0 && 
                        !resultsDiv.textContent.includes('No nearby addresses');
      if (hasResults) {
        updateInstruction('results');
      } else if (resultsDiv.textContent.includes('No nearby addresses')) {
        updateInstruction('noResults');
      }
    }
  });
  observer.observe(resultsDiv, { childList: true, subtree: true });
  
  const f = fromQS();
  showFiltersBadge(f);
</script>
===== END ui/canvass/index.html =====

===== BEGIN scripts/preflight_check.sh =====
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(git rev-parse --show-toplevel 2>/dev/null || pwd)
cd "$ROOT_DIR"

echo "üîç Checking required files..."

MISSING=0
if [[ "${GITHUB_ACTIONS:-}" == "true" ]]; then
  echo "üß© Running in CI ‚Äî skipping .env file check (using secrets instead)"
else
  if [[ -f ".env" ]]; then
    echo "‚úÖ .env found"
  else
    echo "‚ùå .env not found in repo root: $ROOT_DIR/.env"
    MISSING=1
  fi
fi

if [[ -f "ui/wrangler.toml" ]]; then
  echo "‚úÖ ui/wrangler.toml found"
else
  echo "‚ùå ui/wrangler.toml not found: $ROOT_DIR/ui/wrangler.toml"
  MISSING=1
fi

if [[ $MISSING -ne 0 ]]; then
  echo "‚ö†Ô∏è Preflight failed ‚Äî please add the missing files and retry."
  exit 1
fi

echo "üöÄ Ready to deploy from ui/"
exit 0

===== END scripts/preflight_check.sh =====

===== BEGIN scripts/test_api_endpoints.mjs =====
import { spawn } from 'child_process';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const ROOT = path.resolve(__dirname, '..');
const UI_DIR = path.join(ROOT, 'ui');
const API_DIR = path.join(ROOT, 'ui', 'functions', 'api');
const PORT = 8788;
const WRANGLER = 'npx';
const WRANGLER_ARGS = ['wrangler@4.42.0', 'pages', 'dev', UI_DIR, '--port=' + PORT];
const START_TIMEOUT_MS = 60_000; // 60s
const PROBE_METHODS = ['GET', 'OPTIONS', 'POST'];
const ORIGIN = `http://localhost:${PORT}`;
const OUT_MD = path.join(ROOT, 'api-verification.md');

let wranglerProc = null;
let started = false;

function startWrangler() {
  console.log('Starting wrangler pages dev...');
  wranglerProc = spawn(WRANGLER, WRANGLER_ARGS, { stdio: ['ignore', 'pipe', 'pipe'] });

  wranglerProc.stdout.setEncoding('utf8');
  wranglerProc.stderr.setEncoding('utf8');

  const onStdout = (chunk) => {
    process.stdout.write(chunk);
    if (!started && chunk.includes('Ready on http://localhost')) {
      started = true;
      wranglerProc.stdout.removeListener('data', onStdout);
      wranglerProc.stderr.removeListener('data', onStderr);
      console.log('Detected wrangler ready.');
      resolveStart();
    }
  };
  const onStderr = (chunk) => {
    process.stderr.write(chunk);
    if (!started && chunk.includes('Ready on http://localhost')) {
      started = true;
      wranglerProc.stdout.removeListener('data', onStdout);
      wranglerProc.stderr.removeListener('data', onStderr);
      console.log('Detected wrangler ready (stderr).');
      resolveStart();
    }
  };

  wranglerProc.stdout.on('data', onStdout);
  wranglerProc.stderr.on('data', onStderr);

  wranglerProc.on('exit', (code, signal) => {
    if (!started) {
      rejectStart(new Error(`wrangler exited early: ${code} ${signal}`));
    }
  });
}

let resolveStart, rejectStart;
const startPromise = new Promise((res, rej) => { resolveStart = res; rejectStart = rej; });

function waitForStart(timeoutMs = START_TIMEOUT_MS) {
  startWrangler();
  return Promise.race([
    startPromise,
    new Promise((_, rej) => setTimeout(() => rej(new Error('Timeout waiting for wrangler to start')), timeoutMs))
  ]);
}

function findApiFiles(dir) {
  const files = [];
  const items = fs.readdirSync(dir, { withFileTypes: true });
  for (const it of items) {
    const full = path.join(dir, it.name);
    if (it.isDirectory()) {
      files.push(...findApiFiles(full));
    } else if (it.isFile() && it.name.endsWith('.js')) {
      files.push(full);
    }
  }
  return files;
}

async function probeEndpoint(urlPath) {
  const results = { endpoint: urlPath, triedMethod: null, status: null, origin: null, ok: false, diagnostic: null };
  for (const method of PROBE_METHODS) {
    results.triedMethod = method;
    try {
      const res = await httpRequest(method, `http://127.0.0.1:${PORT}${urlPath}`, { Origin: ORIGIN });
      results.status = res.statusCode;
      results.origin = res.headers['access-control-allow-origin'] || null;
      if (res.statusCode === 200) {
        results.ok = true;
        break;
      }
      // if non-200, keep last response for diagnostic if all methods fail
      results.diagnostic = { headers: res.headers, bodyPreview: (res.body || '').toString().slice(0, 200) };
    } catch (err) {
      results.diagnostic = { error: String(err) };
    }
  }
  return results;
}

function httpRequest(method, urlStr, headers = {}) {
  return new Promise((resolve, reject) => {
    const urlObj = new URL(urlStr);
    const opts = {
      method,
      hostname: urlObj.hostname,
      port: urlObj.port,
      path: urlObj.pathname + urlObj.search,
      headers,
    };
    const lib = urlObj.protocol === 'https:' ? awaitImport('https') : awaitImport('http');
    lib.then(({ http, https }) => {
      const httpLib = urlObj.protocol === 'https:' ? https : http;
      const req = httpLib.request(opts, (res) => {
        const chunks = [];
        res.on('data', (c) => chunks.push(c));
        res.on('end', () => {
          res.body = Buffer.concat(chunks);
          resolve(res);
        });
      });
      req.on('error', (e) => reject(e));
      if (method === 'POST') req.write('{}');
      req.end();
    }).catch(reject);
  });
}

// helper to import http/https when needed
function awaitImport(name) {
  return new Promise((res, rej) => {
    try {
      if (name === 'https' || name === 'http') {
        // dynamic import to satisfy ESM top-level
        import(name).then((m) => res({ [name]: m.default || m })).catch(rej);
      } else {
        import(name).then(res).catch(rej);
      }
    } catch (e) { rej(e); }
  });
}

async function main() {
  process.on('SIGINT', cleanupAndExit);
  process.on('SIGTERM', cleanupAndExit);

  try {
    await waitForStart();
  } catch (err) {
    console.error('Failed to start wrangler:', err.message || err);
    cleanupAndExit(1);
    return;
  }

  const files = findApiFiles(API_DIR);
  console.log('Discovered', files.length, 'API files');

  const endpoints = files.map((f) => {
    const rel = path.relative(path.join(ROOT, 'ui', 'functions', 'api'), f);
    const urlPath = '/' + rel.replace(/\\\\/g, '/').replace(/\.js$/, '');
    return { file: f, path: urlPath };
  });

  const results = [];
  for (const ep of endpoints) {
    console.log(`Testing ${ep.path}...`);
    const r = await probeEndpoint(ep.path);
    if (r.ok) console.log(`OK ${ep.path} (${r.status})`);
    else console.log(`FAIL ${ep.path} (last status ${r.status})`);
    results.push(r);
  }

  // write markdown
  const lines = [];
  lines.push('# API Verification Results');
  lines.push('');
  lines.push('| Endpoint | Tried Method | Status | Access-Control-Allow-Origin |');
  lines.push('| --- | --- | ---: | --- |');
  for (const r of results) {
    lines.push(`| ${r.endpoint} | ${r.triedMethod || '-'} | ${r.status || '-'} | ${r.origin || '-'} |`);
  }

  const failed = results.filter(r => !r.ok);
  if (failed.length > 0) {
    lines.push('\n## Diagnostics\n');
    for (const r of failed) {
      lines.push(`### ${r.endpoint}`);
      if (r.diagnostic?.error) {
        lines.push('Error: `' + String(r.diagnostic.error) + '`');
      } else {
        lines.push('- Headers:');
        for (const [k, v] of Object.entries(r.diagnostic?.headers || {})) {
          lines.push(`  - ${k}: ${v}`);
        }
        lines.push('\n- Body preview:');
        lines.push('```');
        lines.push(r.diagnostic?.bodyPreview || '');
        lines.push('```');
      }
      lines.push('');
    }
  }

  fs.writeFileSync(OUT_MD, lines.join('\n'));

  // summary to console
  const total = results.length;
  const okCount = results.filter(r => r.ok).length;
  const missingCors = results.filter(r => !r.origin).length;
  console.log('\nSummary:');
  console.log('Total endpoints tested:', total);
  console.log('Endpoints returning 200:', okCount);
  console.log('Endpoints missing CORS header:', missingCors);

  cleanupAndExit(0);
}

function cleanupAndExit(codeOrEvent = 0) {
  const code = typeof codeOrEvent === 'number' ? codeOrEvent : 0;
  if (wranglerProc) {
    try { wranglerProc.kill(); } catch (e) { /* ignore */ }
  }
  process.exit(code);
}

// run
main().catch((err) => {
  console.error('Unexpected error:', err);
  cleanupAndExit(1);
});

===== END scripts/test_api_endpoints.mjs =====

===== BEGIN instructions/Local_D1_Schema_Snapshot_wy_local_20251026.md =====
# Local D1 Schema Snapshot (wy_local) ‚Äî Updated 2025-10-26

> **Purpose**  
> Point-in-time schema snapshot for local and remote D1 after street normalization/import.  
> This document is **WORM** (write once, read many). For future changes, create a new dated file.

---

## Summary (2025-10-26)

- Core normalization/lookup objects exist **and align** across local and remote:  
  `wy_city_county`, `streets_index`, `voters_addr_norm`, plus views `city_county`, `v_voters_addr_norm`.
- `streets_index` is populated from the cleaned CSV pipeline with deduplicated canonical rows.
- `voters_addr_norm.city_county_id` is **NOT NULL** and has a valid FK to `wy_city_county(id)`.
- Minimal voter phone data (`voter_phones`) imported and deduplicated in both local and remote D1.
- Row counts match: 113,358 records in both local and remote after final import and deduplication.
- Parity verified: no missing files, no duplicates, no schema drift.
- Local contains additional app tables not required in production; remote contains Cloudflare‚Äôs system table.

---

## Objects Inventory

### Local D1 (`wy_local`)
| name               | type  |
|--------------------|-------|
| _cf_METADATA       | table |
| best_phone         | table |
| call_activity      | table |
| canvass_activity   | table |
| city_county_import | table |
| d1_migrations      | table |
| message_templates  | table |
| pulse_optins       | table |
| sqlite_sequence    | table |
| streets_index      | table |
| voter_emails       | table |
| voters             | table |
| voters_addr_norm   | table |
| voter_phones       | table |
| wy_city_county     | table |
| city_county        | view  |
| v_voters_addr_norm | view  |

### Remote D1 (`wy`, production)
| name               | type  |
|--------------------|-------|
| _cf_KV             | table |
| call_activity      | table |
| d1_migrations      | table |
| sqlite_sequence    | table |
| streets_index      | table |
| voters_addr_norm   | table |
| voter_phones       | table |
| wy_city_county     | table |
| city_county        | view  |
| v_voters_addr_norm | view  |

> **Note:** Local includes additional app/support tables (`best_phone`, `canvass_activity`, `message_templates`, `pulse_optins`, `voter_emails`, `voters`, `city_county_import`). Remote includes Cloudflare `_cf_KV`.

---

## Key Tables

### `wy_city_county`
**Role:** Authoritative city/county normalization table used to resolve `city_county_id`.

**Minimal columns (effective):**
- `id` INTEGER PRIMARY KEY  
- `city_norm` TEXT NOT NULL  
- `county_norm` TEXT NOT NULL

**View helper:**
```sql
CREATE VIEW city_county AS
SELECT id, city_norm AS city, county_norm AS county
FROM wy_city_county;
```

### `streets_index`
Role: Canonical, deduplicated street rows per city/county.

Columns (effective):
- street_id INTEGER PRIMARY KEY
- city_county_id INTEGER NOT NULL REFERENCES wy_city_county(id)
- street_prefix TEXT -- e.g., N, S, E, W, NE, ‚Ä¶
- street_core TEXT NOT NULL -- name without house numbers/units
- street_type TEXT -- e.g., ST, RD, AVE, HWY, ‚Ä¶
- street_suffix TEXT -- trailing qualifier when present
- street_canonical TEXT NOT NULL -- [prefix] core [type] [suffix] (single spaces)

Normalization guarantees:
- No leading house numbers in street_core.
- street_canonical is a normalized, trimmed single-space join of present parts.
- Uniqueness: one row per (city_county_id, street_prefix, street_core, street_type, street_suffix).

### `voters_addr_norm`
Role: Normalized voter addresses with resolved city/county.

Columns (effective):
- voter_id TEXT PRIMARY KEY NOT NULL
- ln, fn TEXT
- addr1 TEXT
- city, state TEXT
- zip TEXT
- senate, house TEXT
- city_county_id INTEGER NOT NULL REFERENCES wy_city_county(id)

Indexes (recommended & present):
- idx_voters_addr_norm_city ON (city)
- idx_voters_addr_norm_zip ON (zip)
- idx_voters_addr_norm_addr1_city ON (addr1, city)
- idx_voters_addr_norm_city_addr1 ON (city, addr1)
- idx_voters_addr_norm_city_county_id ON (city_county_id)

**View helper:**
```sql
CREATE VIEW v_voters_addr_norm AS
SELECT
  van.*,
  wcc.city_norm   AS city_resolved,
  wcc.county_norm AS county_resolved
FROM voters_addr_norm AS van
LEFT JOIN wy_city_county AS wcc
  ON wcc.id = van.city_county_id;
```

### `voter_phones`
**Role:** Stores minimal phone data for each voter, deduplicated and parity-checked across environments.

**Columns (effective):**
- `voter_id` TEXT NOT NULL
- `phone10` TEXT NOT NULL
- `phone_e164` TEXT NOT NULL

**Table Relationships:**
- Each `voter_phones.voter_id` should match a `voters.voter_id` (foreign key recommended).
- Unique records per `(voter_id, phone10, phone_e164)` are enforced for deduplication.
- Both local and remote should use the same constraints for consistency.

**Import & Deduplication:**
- Data imported in 57 SQL batch files (2000 records per file, last file smaller).
- Deduplication performed on `(voter_id, phone10, phone_e164)`; only unique rows retained.
- Final row count: 113,358 in both local and remote.

**Verification:**
- Parity confirmed by matching row counts and schema.

---

## Verification Commands (Wrangler)
Run from repo root. Replace worker/wrangler.toml if your config path differs.

Inventory (objects list)
Local
```bash
npx wrangler d1 execute wy_local --local --config worker/wrangler.toml \
  --command "SELECT name, type FROM sqlite_master WHERE type IN ('table','view') ORDER BY type, name;"
```
Remote (production)
```bash
npx wrangler d1 execute wy --remote --env production --config worker/wrangler.toml \
  --command "SELECT name, type FROM sqlite_master WHERE type IN ('table','view') ORDER BY type, name;"
```

voters_addr_norm table shape + FK
Local
```bash
npx wrangler d1 execute wy_local --local --config worker/wrangler.toml \
  --command "PRAGMA table_info(voters_addr_norm); PRAGMA foreign_key_list(voters_addr_norm); PRAGMA foreign_key_check;"
```
Remote
```bash
npx wrangler d1 execute wy --remote --env production --config worker/wrangler.toml \
  --command "PRAGMA table_info(voters_addr_norm); PRAGMA foreign_key_list(voters_addr_norm); PRAGMA foreign_key_check;"
```

streets_index sanity
Local
```bash
npx wrangler d1 execute wy_local --local --config worker/wrangler.toml \
  --command "PRAGMA table_info(streets_index); SELECT COUNT(*) AS streets_rows FROM streets_index;"
```
Remote
```bash
npx wrangler d1 execute wy --remote --env production --config worker/wrangler.toml \
  --command "PRAGMA table_info(streets_index); SELECT COUNT(*) AS streets_rows FROM streets_index;"
```

City coverage check (every city has at least
SELECT c.city, c.county
FROM cities c
LEFT JOIN (
  SELECT DISTINCT city_county_id FROM streets_index
) s ON s.city_county_id = c.id
WHERE s.city_county_id IS NULL
ORDER BY c.county, c.city;"
```
Remote
```bash
npx wrangler d1 execute wy --remote --env production --config worker/wrangler.toml --command "
WITH cities AS (
  SELECT id, city_norm AS city, county_norm AS county FROM wy_city_county
)
SELECT c.city, c.county
FROM cities c
LEFT JOIN (
  SELECT DISTINCT city_county_id FROM streets_index
) s ON s.city_county_id = c.id
WHERE s.city_county_id IS NULL
ORDER BY c.county, c.city;"
```

voter_phones row count (import & parity)
Local
```bash
npx wrangler d1 execute wy_local --local --config worker/wrangler.toml --command "SELECT COUNT(*) AS local_count FROM voter_phones;"
```
Remote
```bash
npx wrangler d1 execute wy --remote --env production --config worker/wrangler.toml --command "SELECT COUNT(*) AS remote_count FROM voter_phones;"
```

---

## Provenance & Notes
This 2025-10-26 snapshot preserves the structure and intent of the prior 2025-10-24 file while incorporating the latest state after street normalization/import and voter phone data migration.

For any future migrations impacting streets_index, voters_addr_norm, or voter_phones, update the next dated snapshot rather than editing this file.






===== END instructions/Local_D1_Schema_Snapshot_wy_local_20251026.md =====

===== BEGIN instructions/project_instructions.md =====
GrassrootsMVT ‚Äì Project Instructions

0. Never invent, assume, guess d1 field names in this project.  

0.1 Alway complete d1 changes locally and test locally before recommending changes to the d1 in production.

0.2  Suggest changes that work both locally first and can be adapted to production later.  

0.3  Review tree.txt before suggesting cmds suggest the proper folder for execution.  e.g execute from root or execute from worker or cd worker

0.4 Migrations naming convention for this project name migrations sequentially 0002(name_varies).sql 0003(name_varies).sql etc. Migrations belong in worker/db/migrations not in db/migrations.  Single source of truth for D1 migrations: worker/db/migrations/

Filenames: zero-padded sequential numbers, then a short slug, for example
0010_v_street_tokens.sql, 0011_streets_index.sql

The top-level db/migrations/ path is deprecated.

1) Project description (what we‚Äôre building)

A simple Volunteer Hub (Pages) backed by a single API (Worker) with Cloudflare Zero Trust (Access) protecting only the API. The UI always talks to the API same-origin via /api/... so there‚Äôs no CORS pain and no cross-domain redirects.

UI: Cloudflare Pages site (e.g., volunteers.grassrootsmvt.org) serving static HTML/JS/CSS.

API: Cloudflare Worker bound to the domain routes volunteers.grassrootsmvt.org/api/* (and optionally grassrootsmvt.org/api/*) that:

terminates Access (trusts CF injected auth headers),

exposes endpoints like /api/whoami, /api/streets, /api/canvass, etc.

Access (Zero Trust): one application protecting the API routes; the UI remains public.

Source of truth: running code and configuration in the repo + Cloudflare dashboard.
Not a source of truth: any AI notes or docs (including this file). They are snapshots/observations at a point in time.

2) Top goals (keep these in front of us)

Single login + full functionality

Access protects only /api/*, UI is public.

After Access completes, cookies are valid for both volunteers.grassrootsmvt.org and /api/*.

Eliminate CORS and redirect loops

UI must only call fetch('/api/...') built from environmentConfig.getApiUrl('...').

Never hardcode https://api.grassrootsmvt.org/... in UI code.

Keep it simple

Minimal scripts, small diffs, Copilot-friendly ‚Äúapply patch‚Äù workflow.

Use one Worker (grassrootsmvt-production) with clear route assignments.

Repeatable deploys

One deploy script for Worker (API) and Pages (UI).

No local dev required to deploy prod.

3) Current layout & names

Pages project: grassrootsmvt-production

Custom domain: https://volunteers.grassrootsmvt.org

Worker (API): grassrootsmvt-production (name visible in CF Worker list)

Routes:

volunteers.grassrootsmvt.org/api/* ‚Üí assigned to grassrootsmvt-production

(optional) grassrootsmvt.org/api/* ‚Üí assigned to grassrootsmvt-production

Zero Trust Access: single application with policy AUD matching the Worker‚Äôs POLICY_AUD.

Cookie domain: the Pages domain (volunteers.grassrootsmvt.org) or the zone; not /cdn-cgi/....

4) Doc index (living notes)

These are helpful, but not canonical‚Äîtreat them as context, not truth.

project_instructions.md (this file): how we work, goals, pitfalls, workflows.

testing.md: short journal entries per change (what changed, quick test results).

tree.txt: curated tree of project files only (no node_modules, no build artifacts).

scripts/deploy_prod.sh: production deployment script (Worker + Pages).

ui/config/environments.js: the only way UI builds API URLs (same-origin).

worker/wrangler.toml: Worker bindings, env, and no /cdn-cgi/* routes.

5) Pitfalls we‚Äôve already found (and how to avoid them)

AUD-in-path / Access redirects showing team-domain/cdn-cgi/...
Cause: browser followed a cross-origin whoami redirect.
Fix: UI must call same-origin /api/whoami (via environmentConfig.getApiUrl('whoami')).

CORS blocked
Cause: hardcoded https://api.grassrootsmvt.org/... in UI.
Fix: never hardcode API origin in UI; use getApiUrl().

‚Äúnull worker‚Äù blocking a route assignment
Cause: stale route assigned to ‚Äúnull‚Äù.
Fix: Cloudflare ‚Üí Workers ‚Üí Unassign stale route, then redeploy. (If dashboard says ‚Äútoo many deployments‚Äù, follow CF doc to prune or delete and recreate the route/project.)

Login loops (401 from /api/whoami)
Causes:

Calling /cdn-cgi/access/cookies manually,

Bad finish URL,

API calls before Access cookie exists.
Fix: Use /api/ping?finish=/api/auth/finish?to=<returnUrl> pattern and only check /api/whoami after Access returns.

WSL / DNS weirdness
Cause: WSL nameserver overrides.
Fix: confirm with dig or curl --resolve ... and wait for local DNS update if needed.

Duplicated component designs (e.g., streetAutocomplete)
Cause: legacy and ‚Äúnew‚Äù APIs mixed.
Fix: converge on one component + one API shape. Favor the simple one in this repo (see ‚ÄúUI rules‚Äù below).

6) Cloudflare Zero Trust (what works)

Protect only /api/* (Worker routes).

Do not attach Workers to /cdn-cgi/*. Let Cloudflare handle Access endpoints.

Access app AUD in Zero Trust must match POLICY_AUD the Worker expects (and vice versa).

Cookie domain should cover volunteers.grassrootsmvt.org so subsequent same-origin /api/* calls carry the cookie.

In the Worker, normalize /api/... to app routes and do not rewrite or proxy /cdn-cgi/*.

7) How we work with Copilot (simple + repeatable)
A) Requesting a review (Copilot prompt)

‚ÄúScan the repo for direct fetch('https://api.grassrootsmvt.org') calls or any cross-origin URLs. Replace all with environmentConfig.getApiUrl('<endpoint>'). Generate a minimal git patch for each file.‚Äù

B) Applying a small patch

Use the ‚Äúapply patch‚Äù style:

git checkout -b fix/same-origin-api
git apply -p0 <<'PATCH'
*** Begin Patch
*** Update File: ui/config/environments.js
@@
-const baseOrigin = apiBaseOverride || 'https://api.grassrootsmvt.org';
+const baseOrigin = apiBaseOverride || (isBrowser ? location.origin : 'https://volunteers.grassrootsmvt.org');
*** End Patch
PATCH

git commit -am "use same-origin base for API urls"

C) Undoing an accidental big drop-in
# Revert the working tree to HEAD (preserve untracked):
git restore --source=HEAD --worktree -- .
# Or selectively:
git checkout -- path/to/file.js

8) Repo review workflow (quick and consistent)

Sync & branch

git pull --rebase
git checkout -b chore/review-YYYYMMDD


Project scan (CI-less local)

# Only project files, no vendor
tree -a -I 'node_modules|.git|dist|.wrangler|.cache|.parcel-cache|build' > tree.txt
grep -R "https://api.grassrootsmvt.org" -n ui worker || true
grep -R "/cdn-cgi/access" -n ui worker || true


Sanity checks

ui/config/environments.js returns /api/... for production.

No Worker route on /cdn-cgi/*.

Workers dashboard shows volunteers.grassrootsmvt.org/api/* assigned to the single Worker.

Minimal fixes via patches (see ¬ß7B).

Zip only modified files

# create zip of modified files since main
git diff --name-only origin/main...HEAD | zip modified_files_$(date +%Y%m%d_%H%M).zip -@


Commit + PR

git commit -am "scan/fixes: same-origin calls, no cdn-cgi worker, small UI fixes"
git push -u origin HEAD

9) Deployments
A) Production (no local dev required)
# From repo root
bash scripts/deploy_prod.sh


scripts/deploy_prod.sh should:

Deploy Worker to prod (npx wrangler deploy --env production).

Deploy Pages (npx wrangler pages deploy ./ui --project-name grassrootsmvt-production --commit-dirty=true).

Verify:

curl -I https://volunteers.grassrootsmvt.org ‚Üí 200

curl -I https://volunteers.grassrootsmvt.org/api/ping ‚Üí 302 (unauth) or 200 (auth session)

curl -I https://volunteers.grassrootsmvt.org/config/environments.js ‚Üí 200 and shows same-origin base.

If a route says ‚Äúalready assigned to null‚Äù: unassign in dashboard (Workers ‚Üí Overview ‚Üí Routes), then redeploy.

Local ‚Üî Production dual-flow (don‚Äôt break prod while you test locally).
We support two modes without code churn: (1) Production ‚Äì UI on Pages (volunteers‚Ä¶) calling the Worker at same-origin /api/* with Cloudflare Access enforced; (2) Local test ‚Äì UI served by wrangler pages dev and API by wrangler dev with ENVIRONMENT!=production so shouldBypassAuth() is true and CORS allows http://localhost. The UI must always build URLs via environmentConfig.getApiUrl('<endpoint>') (never hardcode full origins); in local mode, you may optionally point the UI at a non-default API with localStorage.GRMVT_API_BASE="http://localhost:8787" (this override is only honored on localhost). The Worker must not intercept /cdn-cgi/* in either mode; Access owns that path. Keep ALLOW_ORIGIN including only Pages in prod and localhost in dev. Never commit local-only toggles as prod defaults (e.g., don‚Äôt flip ENVIRONMENT=production off, don‚Äôt bake cross-origin URLs into the UI). If local breaks but prod must keep working, revert local toggles, verify /config/environments.js returns same-origin URLs, and confirm the Access app AUD still matches the Worker‚Äôs POLICY_AUD.

10) UI rules (to keep everything stable)

Always import ui/config/environments.js and call:

environmentConfig.getApiUrl('whoami') ‚Üí /api/whoami

environmentConfig.getApiUrl('streets') ‚Üí /api/streets

Never hardcode api.grassrootsmvt.org in the UI.

No manual hits to /cdn-cgi/access/* from UI code.

One StreetAutocomplete design (the converged one). If legacy code remains, remove it rather than keep two styles.

If a component needs auth: call /api/ping?finish=/api/auth/finish?to=<returnUrl> to ‚Äúkick‚Äù and then wait for Access to return before calling /api/whoami.

11) Worker rules (auth & routes)

Don‚Äôt intercept /api/cdn-cgi/* ‚Üí return fetch(request).

Normalize /api/... internally (/api/whoami ‚Üí /whoami inside Worker).

Read CF-Access-Authenticated-User-Email to identify the user.

ALLOW_ORIGIN for prod must include only the Pages domain (https://volunteers.grassrootsmvt.org).

12) Create a bundle of modified files (zip)

Since last commit:

git diff --name-only > /tmp/changed.txt
zip modified_$(date +%Y%m%d_%H%M).zip -@ < /tmp/changed.txt


Compared to main:

git fetch origin
git diff --name-only origin/main...HEAD | zip modified_vs_main_$(date +%Y%m%d_%H%M).zip -@

13) Update GitHub (short & sweet)
git add -A
git commit -m "deploy: worker+pages; same-origin env; Access-stable auth flow"
git push
# open PR from your branch with a 2-3 bullet summary


Add a short journal entry in testing.md:

What changed (1-2 bullets)

Smoke tests you ran (URLs, expected vs actual)

Any follow-ups

Example entry:

## 2025-10-19
- Switched UI to same-origin API calls via environmentConfig.
- Assigned Worker to volunteers.grassrootsmvt.org/api/*; removed cdn-cgi routes.
- Tests: /config/environments.js 200, /api/ping 302 (unauth), login ‚Üí /api/whoami 200.

14) ‚ÄúIf things go sideways‚Äù checklist

Network tab shows any api.grassrootsmvt.org calls? ‚Üí Fix UI code to same-origin.

Seeing skovgard.cloudflareaccess.com/cdn-cgi/... in responses? ‚Üí A UI call followed a redirect; ensure you never call cross-origin & let /api/ping handle forwarding.

401 on /api/whoami after login?

Confirm Access cookie present for volunteers.grassrootsmvt.org.

Confirm Worker routes on /api/* not /cdn-cgi/*.

Confirm Access policy AUD matches Worker POLICY_AUD.

15) Open items (keep list short)

 Remove legacy ‚Äúsecond design‚Äù of Street Autocomplete; keep the converged one.

 Restore ‚ÄúNew Contact Entry‚Äù form using /api/contact-staging.

 Confirm whoami display shows real email post-auth.

## Deliverables

1. **Interactive Landing Page**
   - Entry point for volunteers. Allows selection of activity (canvass, call, new contact) and targeting method (city or district).
   - Linked to activity pages: Canvass, Call, and New Contact.

2. **Canvass Page**
   - Door-to-door canvassing interface for volunteers.
   - Features voter search, address autocomplete, contact status integration, and data persistence.
   - Uses schema: `voters`, `voters_addr_norm`, `streets_index`, `wy_city_county`, and `voter_phones`.

3. **New Contact Page**
   - Rich contact form for adding or updating volunteer interactions.
   - Integrates with canvass page and contact status tracking.
   - Uses schema: `voters`, `voter_contacts`, `voter_contact_staging`, `voter_phones`.

4. **Call Page**
   - Phone banking interface for volunteers.
   - Handles authentication, fetches next voter, and records call outcomes.
   - Uses schema: `voters`, `voter_phones`, `call_activity`.

## Documentation Consolidation

- All deliverable pages (Landing, Canvass, New Contact, Call) are documented in the `docs` folder:
  - `grassrootsmvt_ui_goals.md`: UI flow, landing page, activity selection, integration points.
  - `canvass_page_documentation.md`: Canvass page features, filters, workflow, schema usage.
  - `contact_system_comprehensive.md`: Contact page, form logic, integration with canvass and contact status, schema references.
  - `call_page_loop_prevention.md`: Call page authentication, workflow, schema usage.
  - `SEEDED_DATA_GUIDE.md`, `LOCALHOST_FUNCTIONALITY_SUMMARY.md`: Usage examples, schema references for all pages.

- All documentation should reference the current schema as described in `instructions/Local_D1_Schema_Snapshot_wy_local_20251026.md`:
  - Key tables: `voters`, `voters_addr_norm`, `streets_index`, `wy_city_county`, `voter_phones`, `voter_contacts`, `voter_contact_staging`, `call_activity`.
  - Ensure all page documentation and examples use the latest schema and field names.

16) Use tree.txt

Regenerate after structural changes if the tree changes include it in the zip folder (no vendor folders):

tree -a -I 'node_modules|.git|dist|.wrangler|.cache|build|.parcel-cache' > tree.txt

## 17) Local D1 Database Access (Custom Mirror Setup)

**Overview**: This project uses a **non-standard** local D1 configuration that mirrors the production database for development. This is not a typical Cloudflare setup but provides access to real Wyoming voter data during local development.

### wrangler.toml Configuration Requirements

The `worker/wrangler.toml` file must include a **local default section** to enable D1 access during `wrangler dev`:

```toml
# Local default (used by: wrangler dev --local)
[vars]
ENVIRONMENT = "local"
DATA_BACKEND = "d1"
ALLOW_ORIGIN_DEV = "http://127.0.0.1:8788,http://localhost:8788,http://localhost:5173"

[[d1_databases]]
binding = "d1"                    # must match your code: env.d1
database_name = "wy_local"        # local file-backed DB is auto-managed by wrangler
database_id = "de78cb41-176d-40e8-bd3b-e053e347ac3f"
migrations_dir = "db/migrations"
```

### Development Environment Access

**Standard Environments** (dev/production):
- `[env.dev]` and `[env.production]` use remote Cloudflare D1 databases
- Require `wrangler dev --env dev` or production deployment
- May have connectivity/auth limitations in local development

**Local Environment** (local database mirror):
- Default `wrangler dev` (no --env flag) uses local D1 configuration
- Provides full access to mirrored production data (274,656+ voter records)
- Enables testing with real street names, addresses, and geographic data
- **Requirement**: Must have local database file synchronized with production

### Database Schema & Usage

**Full schema documentation**: See `instructions/database_schema_reference.md`

**Key tables available locally**:
- `voters` - Core voter registration (274,656 records)
- `v_voters_addr_norm` - Complete voter + address view
- `voter_contacts` - Volunteer interaction tracking
- `voter_contact_staging` - New contact verification pipeline

**Testing database connectivity**:
```bash
# Test D1 binding and data access
curl -s "http://localhost:8787/api/test-d1" | jq

# Test street autocomplete with real data
curl -s -X POST "http://localhost:8787/api/streets" \
  -H "Content-Type: application/json" \
  -d '{"q":"main","county":"ALBANY","city":"LARAMIE","limit":10}' | jq
```

### Important Notes

1. **Non-Standard Setup**: This local D1 mirror configuration is **not documented** in Cloudflare's standard practices
2. **Data Sync**: Local database must be manually synchronized with production periodically
3. **Environment Detection**: Worker code detects `env.ENVIRONMENT === "local"` to use appropriate query logic
4. **Fallback Behavior**: If D1 fails, APIs fall back to static test data for development continuity
5. **Production Safety**: Local configuration does not affect production deployments

### Troubleshooting

**D1 not accessible**: Ensure `wrangler dev` runs without `--env` flag to use local configuration
**Empty results**: Verify database sync and check `instructions/database_schema_reference.md` for correct table/column names
**Connection errors**: Check wrangler.toml syntax and database_id matches your local setup

## 18) Common Module Script Issues

### MIME Type Error: "Expected JavaScript but got text/html"

**Error Message**: 
```
Failed to load module script: Expected a JavaScript module script but the server responded with a MIME type of "text/html". Strict MIME type checking is enforced for module scripts per HTML spec.
```

**Root Cause**: 
Incorrect script paths in HTML files that include `/ui/` prefix when files are served from the UI root directory.

**Common Examples**:
- ‚ùå `<script type="module" src="/ui/canvass/canvass.js"></script>`
- ‚ùå `<script type="module" src="/ui/shared/streetAutocomplete.js"></script>`
- ‚úÖ `<script type="module" src="/canvass/canvass.js"></script>`
- ‚úÖ `<script type="module" src="/shared/streetAutocomplete.js"></script>`

**Resolution**:
1. **Remove `/ui/` prefix** from script paths in HTML files
2. **Verify file structure**: UI files are served from `ui/` directory root
3. **Check _routes.json**: Ensure module files aren't excluded from serving
4. **Add explicit MIME types** to `_headers` file if needed:

```plaintext
# Add to ui/_headers if needed
*.js
  Content-Type: application/javascript; charset=utf-8
```

**Related Files to Check**:
- `ui/canvass/index.html` - Canvass page module imports
- `ui/volunteer/canvass.html` - Volunteer canvass interface  
- `ui/index.html` - Main landing page scripts
- `ui/_routes.json` - Route inclusion/exclusion rules
- `ui/_headers` - MIME type configurations

**Testing Fix**:
```bash
# Test module script loads correctly
curl -I http://localhost:8788/canvass/canvass.js
# Should return: Content-Type: application/javascript

# Test in browser console
fetch('/canvass/canvass.js').then(r => console.log(r.headers.get('content-type')))
# Should return: "application/javascript; charset=utf-8"
```

## Local-Dev First (current working mode)

**Status:** We are developing and testing on localhost only. Production is unchanged. All instructions in this section assume local dev.

### Goals
- Keep the UI and API running locally with the same code paths we will use in production.
- Enforce the same-origin call pattern (`/api/*`) via `ui/config/environments.js`.
- Validate D1 and API endpoints with terminal-only smoke tests.

### Runbook

1. **Start the Worker API (port 8787 by default)**
   ```bash
   cd worker
   # Ensure ALLOW_ORIGIN_DEV is set for CORS (e.g., http://localhost:8788)
   # export ALLOW_ORIGIN_DEV=http://localhost:8788
   npx wrangler dev --local --config wrangler.toml
   ```
2. **Start the UI (Pages, port 8788)**
   ```bash
   cd ui
   npx wrangler pages dev . --port 8788
   ```
3. **Local override (optional)**
   In the browser console during local testing you may set:
   ```js
   localStorage.GRMVT_API_BASE = "http://localhost:8787";
   ```
   The `ui/config/environments.js` helper will honor this override only on localhost or 127.0.0.1.

4. **Terminal smoke tests**

   - API Health:
     ```bash
     curl -i http://localhost:8787/api/health
     ```
   - UI config reachable:
     ```bash
     curl -I http://localhost:8788/config/environments.js
     ```
   - Direct API call (mirrors what the UI will call):
     ```bash
     curl -i http://localhost:8787/api/health
     ```
   - Database checks:
     ```bash
     npx wrangler d1 execute wy_local --local --config worker/wrangler.toml \
       --command "SELECT name FROM sqlite_master WHERE type IN ('table','view') ORDER BY type, name;"
     ```
5. **Database checks**

npx wrangler d1 execute wy_local --local --config worker/wrangler.toml \
  --command "SELECT name FROM sqlite_master WHERE type IN ('table','view') ORDER BY type, name;"

Source-of-truth documents (WORM)

Schema snapshot: see FILE: Local_D1_Schema_Snapshot_wy_local_*.md in chat (immutable).

Current status and run commands: STATUS_CURRENT.md (living).

When we‚Äôre ready to flip to production, we will update STATUS_CURRENT.md and leave the dated snapshots untouched.
===== END instructions/project_instructions.md =====

===== BEGIN instructions/STATUS_CURRENT.md =====
# STATUS_CURRENT

This is the single living status page. Dated snapshots such as `PROJECT_SUMMARY_YYYYMMDD.md`, `PRODUCTION_REVIEW_SUMMARY_YYYYMMDD.md`, and `Local_D1_Schema_Snapshot_wy_local_YYYYMMDD.md` remain immutable and link here.

## Domains and origins
- UI domain (Pages): https://volunteers.grassrootsmvt.org
- API route: same origin `/api/*` from the UI
- CORS allowlist (Worker env var): https://volunteers.grassrootsmvt.org
- Cloudflare Access: enabled on `/api/*`, AUD is the app Audience for volunteers.grassrootsmvt.org

## Environment parity
- Local UI: `wrangler pages dev ./ui`
- Local API: `wrangler dev` in `worker/` with D1 binding `wy_local`
- Local override allowed: `localStorage.GRMVT_API_BASE="http://localhost:8787"` for development only

## Data bindings
- D1 (prod): binding `DB`, database `wy_preview`  ‚Üê update if your prod DB name differs
- D1 (local): binding `DB`, database `wy_local`

## Migrations and schema
- Migrations head: latest committed migration in `worker/migrations/`  ‚Üê update this line when you add a new migration
- Latest schema snapshot: `Local_D1_Schema_Snapshot_wy_local_20251026.md`
- Deltas since last snapshot: plan migration to enforce `voters_addr_norm.voter_id NOT NULL` (currently PK, notnull=0 in snapshot). Track in `SCHEMA_DELTAS.md`.

- Migrations head (preview): <paste last file shown by `migrations list`>, applied on 2025-10-24.
- Latest remote pre-snapshot (preview): remote_pre_migrations_preview_20251024_0810.txt
- Latest remote post-snapshot (preview): remote_post_migrations_preview_<STAMP>.txt

API smoke tests (local):
- GET /api/health: 200, { status: "ok", d1: "ok" } on 2025-10-24.


## API smoke tests
- `GET /api/health`: expect 200 with `{ d1: "ok" }`
- `GET /api/ping`: expect 302 to Access when not signed in, 200 when signed in
- `GET /api/whoami`: expect 200 with identity after Access

## Known blockers and decisions
- All UI requests must use `environmentConfig.getApiUrl()` so the browser calls same origin. No hardcoded `https://api‚Ä¶` anywhere in the UI.
- CORS allowlist must match the UI domain exactly in production.

## Next actions
1) Search the UI for any hardcoded API base URLs and replace with `environmentConfig.getApiUrl(...)`.  
2) Set `ALLOW_ORIGIN` in `worker/wrangler.toml` to `https://volunteers.grassrootsmvt.org` and deploy the Worker.  
3) Run smoke tests above and record the results here.  
4) After production is stable, create a migration to set `voters_addr_norm.voter_id NOT NULL`. Update `SCHEMA_DELTAS.md`.
# STATUS_CURRENT

**As of:** 2025-10-24 17:00 (America/Denver)

## Environments
- **Local:** healthy. `/api/health` ‚Üí `{"status":"ok","d1":"ok"}`
- **Preview (wy_preview):** healthy. Schema matches production.
- **Production (wy):** healthy. Schema matches local/preview.

## Database (Cloudflare D1)
- **Primary table:** `voters_addr_norm` (TABLE)
  - Columns: `voter_id (PK, NOT NULL)`, `ln`, `fn`, `addr1`, `city`, `state`, `zip`, `senate`, `house`, `city_county_id (NOT NULL, FK ‚Üí wy_city_county(id))`
  - Indexes: `city`, `zip`, `addr1,city`, `city,addr1`, `city_county_id`
- **Views:**
  - `v_voters_addr_norm` = `voters_addr_norm` ‚üó `wy_city_county` with `city_resolved`, `county_resolved`
  - `city_county` = alias view on `wy_city_county` exposing `city`, `county`
- **Other tables present:** `wy_city_county`, `streets_index` (FK ‚Üí wy_city_county), plus app tables (calls, volunteers, etc.).

## Migrations (active dir)
- ‚úÖ `0001_create_wy_city_county.sql`
- ‚úÖ `0002_create_streets_index.sql`
- ‚úÖ `0011_baseline_after_alignment.sql`
- ‚úÖ `0012_enforce_fk_voters_addr_norm.sql` (drops dependent view first, rebuilds table with NOT NULL + FK, recreates view)

Legacy migrations `0002_create_call_activity.sql`, `0003`‚Äì`0010` were removed/archived to prevent replay.

## Integrity
- `PRAGMA foreign_key_check;` ‚Üí **OK** (preview & production)
- `voters_addr_norm.city_county_id` NULLs ‚Üí **0** (preview & production)

## Snapshots (WORM)
- Added: `remote_schema_wy_preview_<STAMP>.txt`, `remote_schema_wy_<STAMP>.txt` (full `sqlite_master`)
- Keep these files in **FILE: here** to prevent drift.

## Next actions
1. **Deploy worker (prod)** if `/api/health` doesn‚Äôt return promptly after schema changes.
2. **Docs**: commit this STATUS_CURRENT.md, and ensure `instructions/project_instructions.md` references this file and the snapshot filenames.
3. **Guardrails**: future migrations must be idempotent (no `BEGIN/COMMIT`; use `IF NOT EXISTS`), and any manual DB edit must be mirrored by a migration.

===== END instructions/STATUS_CURRENT.md =====

===== BEGIN instructions/zip_prompt.md =====
You are my project assistant.

Read the file tree.txt from the project root.

Your task is to generate a single zip command that includes **only the specific source files** we‚Äôre actively maintaining.  
The goal is to create a lightweight, review-focused snapshot ‚Äî sometimes limited to a few files, sometimes complete.

Follow these rules:

1. Include only real source files listed in tree.txt.
2. Exclude all vendor, build, and dependency directories:
   node_modules, .git, dist, .wrangler, .cache, build, .parcel-cache, logs, temp_api_backup, project-transfer.
3. Do **not** use wildcards (`*`) or recursive folders.
4. Each file path should appear only once, written cleanly on its own line.
5. Output only the **zip command**, no commentary or extra text.
6. Use this naming format for the zip:
   `snapshot_YYYYMMDD_HHMM.zip`
7. Keep the list concise and readable, backslash-escaped for line breaks.
8. The purpose of the zip is **fast project review** ‚Äî sometimes focused (e.g., UI bugfix), sometimes full snapshot.

Format your output like this:

zip snapshot_20251019_1530.zip \
  worker/src/index.js \
  worker/src/routes/whoami.js \
  ui/canvass/index.html \
  ui/contact-form/index.html \
  ui/config/environments.js \
  README.md \
  worker/wrangler.toml

If I specify a focus (for example, "restore email workflow" or "street autocomplete review"), include only the files in tree.txt relevant to that focus area.  
Otherwise, include all actively maintained non-vendor source files.


===== END instructions/zip_prompt.md =====

